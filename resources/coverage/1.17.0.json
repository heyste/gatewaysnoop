{"release":"1.17.0","release_date":"2019-12-07T00:00:00","spec":"https://raw.githubusercontent.com/kubernetes/kubernetes/v1.17.0/api/openapi-spec/swagger.json","sources":["https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs/ci-kubernetes-e2e-gce-cos-k8sstable1-default/1278124757790756864"],"endpoints":[{"endpoint":"connectCoreV1DeleteNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect DELETE requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1DeleteNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect DELETE requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1DeleteNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect DELETE requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1DeleteNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect DELETE requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1DeleteNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect DELETE requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1DeleteNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect DELETE requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1GetNamespacedPodAttach","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/attach","description":"connect GET requests to attach of Pod","kind":"PodAttachOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1GetNamespacedPodExec","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/exec","description":"connect GET requests to exec of Pod","kind":"PodExecOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":true,"tests":["[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]"]},{"endpoint":"connectCoreV1GetNamespacedPodPortforward","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/portforward","description":"connect GET requests to portforward of Pod","kind":"PodPortForwardOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":false,"tests":["[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets"]},{"endpoint":"connectCoreV1GetNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect GET requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1GetNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect GET requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should do a rolling update of a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Services should create endpoints for unready pods"]},{"endpoint":"connectCoreV1GetNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect GET requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1GetNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect GET requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":true,"tests":["[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]"]},{"endpoint":"connectCoreV1GetNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect GET requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1GetNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect GET requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":true,"tests":["[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[sig-instrumentation] Cadvisor should be healthy on every node.","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource  [Conformance]"]},{"endpoint":"connectCoreV1HeadNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect HEAD requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1HeadNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect HEAD requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1HeadNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect HEAD requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1HeadNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect HEAD requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1HeadNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect HEAD requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1HeadNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect HEAD requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1OptionsNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect OPTIONS requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1OptionsNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect OPTIONS requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1OptionsNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect OPTIONS requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1OptionsNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect OPTIONS requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1OptionsNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect OPTIONS requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1OptionsNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect OPTIONS requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PatchNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect PATCH requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PatchNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect PATCH requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PatchNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect PATCH requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PatchNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect PATCH requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PatchNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect PATCH requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PatchNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect PATCH requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PostNamespacedPodAttach","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/attach","description":"connect POST requests to attach of Pod","kind":"PodAttachOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PostNamespacedPodExec","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/exec","description":"connect POST requests to exec of Pod","kind":"PodExecOptions","version":"v1","group":"","action":"connect","tested":true,"conf_tested":true,"tests":["[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] Volumes ConfigMap should be mountable",null]},{"endpoint":"connectCoreV1PostNamespacedPodPortforward","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/portforward","description":"connect POST requests to portforward of Pod","kind":"PodPortForwardOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PostNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect POST requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PostNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect POST requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PostNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect POST requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PostNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect POST requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PostNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect POST requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PostNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect POST requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PutNamespacedPodProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy","description":"connect PUT requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PutNamespacedPodProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}","description":"connect PUT requests to proxy of Pod","kind":"PodProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PutNamespacedServiceProxy","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy","description":"connect PUT requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PutNamespacedServiceProxyWithPath","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}","description":"connect PUT requests to proxy of Service","kind":"ServiceProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PutNodeProxy","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy","description":"connect PUT requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"connectCoreV1PutNodeProxyWithPath","level":"stable","category":"core","path":"/api/v1/nodes/{name}/proxy/{path}","description":"connect PUT requests to proxy of Node","kind":"NodeProxyOptions","version":"v1","group":"","action":"connect","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations","description":"create a MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]"]},{"endpoint":"createAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations","description":"create a ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]"]},{"endpoint":"createApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions","description":"create a CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema"]},{"endpoint":"createApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices","description":"create an APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]",null]},{"endpoint":"createAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions","description":"create a ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets","description":"create a DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments","description":"create a Deployment","kind":"Deployment","version":"v1","group":"apps","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"endpoint":"createAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets","description":"create a ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path",null]},{"endpoint":"createAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets","description":"create a StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"post","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume",null]},{"endpoint":"createAuthenticationV1TokenReview","level":"stable","category":"authentication","path":"/apis/authentication.k8s.io/v1/tokenreviews","description":"create a TokenReview","kind":"TokenReview","version":"v1","group":"authentication.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]"]},{"endpoint":"createAuthorizationV1NamespacedLocalSubjectAccessReview","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/v1/namespaces/{namespace}/localsubjectaccessreviews","description":"create a LocalSubjectAccessReview","kind":"LocalSubjectAccessReview","version":"v1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAuthorizationV1SelfSubjectAccessReview","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/v1/selfsubjectaccessreviews","description":"create a SelfSubjectAccessReview","kind":"SelfSubjectAccessReview","version":"v1","group":"authorization.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]"]},{"endpoint":"createAuthorizationV1SelfSubjectRulesReview","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/v1/selfsubjectrulesreviews","description":"create a SelfSubjectRulesReview","kind":"SelfSubjectRulesReview","version":"v1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAuthorizationV1SubjectAccessReview","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/v1/subjectaccessreviews","description":"create a SubjectAccessReview","kind":"SubjectAccessReview","version":"v1","group":"authorization.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should update PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API should support building a client with a CSR","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl alpha client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl rolling-update should support rolling-update to same image  [Conformance]","[sig-cli] Kubectl client Kubectl run","[sig-cli] Kubectl client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Kubectl run default should create an rc or deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run deployment should create a deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run job should create a job from an image when restart is OnFailure  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should do a rolling update of a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Cadvisor should be healthy on every node.","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: udp","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: udp","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PersistentVolumes:vsphere should test that deleting a PVC before the pod does not cause pod deletion to fail on vsphere volume detach","[sig-storage] PersistentVolumes:vsphere should test that deleting the Namespace of a PVC and Pod causes the successful detach of vsphere volume","[sig-storage] PersistentVolumes:vsphere should test that deleting the PV before the pod does not cause pod deletion to fail on vspehre volume detach","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volume Placement should create and delete pod with multiple volumes from different datastore","[sig-storage] Volume Placement should create and delete pod with multiple volumes from same datastore","[sig-storage] Volume Placement should create and delete pod with the same volume source attach/detach to different worker nodes","[sig-storage] Volume Placement should create and delete pod with the same volume source on the same worker node","[sig-storage] Volume Placement test back to back pod creation and deletion with different volume sources on the same worker node","[sig-storage] Volumes ConfigMap should be mountable","[sig-storage] vsphere statefulset vsphere statefulset testing","[sig-storage] Zone Support Verify a pod fails to get scheduled when conflicting volume topology (allowedTopologies) and pod scheduling constraints(nodeSelector) are specified","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on allowed zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on a VSAN capability, datastore and compatible zone specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in the storage class. (No shared datastores exist among both zones)","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and datastore specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones, datastore and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with allowedTopologies","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with multiple allowedTopologies","[sig-storage] Zone Support Verify a pod is created on a non-Workspace zone and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a PVC creation fails when multiple zones are specified in the storage class without shared datastores among the zones in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify dynamically created pv with allowed zones specified in storage class, shows the right zone information on its labels","[sig-storage] Zone Support Verify dynamically created pv with multiple zones specified in the storage class, shows both the zones on its labels","[sig-storage] Zone Support Verify PVC creation fails if no zones are specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only datastore is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only storage policy is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if the availability zone specified in the storage class have no shared datastores under it.","[sig-storage] Zone Support Verify PVC creation with an invalid VSAN capability along with a compatible zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with compatible policy and datastore without any zones specified in the storage class fails (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation with incompatible datastore and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storage policy along with compatible zone and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storagePolicy and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible zone along with compatible storagePolicy and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with invalid zone specified in storage class fails",null]},{"endpoint":"createAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers","description":"create a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs","description":"create a Job","kind":"Job","version":"v1","group":"batch","action":"post","tested":true,"conf_tested":true,"tests":["[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion",null]},{"endpoint":"createCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases","description":"create a Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]",null]},{"endpoint":"createCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces","description":"create a Namespace","kind":"Namespace","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should update PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API should support building a client with a CSR","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl alpha client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl rolling-update should support rolling-update to same image  [Conformance]","[sig-cli] Kubectl client Kubectl run","[sig-cli] Kubectl client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Kubectl run default should create an rc or deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run deployment should create a deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run job should create a job from an image when restart is OnFailure  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should do a rolling update of a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Cadvisor should be healthy on every node.","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: udp","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: udp","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PersistentVolumes:vsphere should test that deleting a PVC before the pod does not cause pod deletion to fail on vsphere volume detach","[sig-storage] PersistentVolumes:vsphere should test that deleting the Namespace of a PVC and Pod causes the successful detach of vsphere volume","[sig-storage] PersistentVolumes:vsphere should test that deleting the PV before the pod does not cause pod deletion to fail on vspehre volume detach","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volume Placement should create and delete pod with multiple volumes from different datastore","[sig-storage] Volume Placement should create and delete pod with multiple volumes from same datastore","[sig-storage] Volume Placement should create and delete pod with the same volume source attach/detach to different worker nodes","[sig-storage] Volume Placement should create and delete pod with the same volume source on the same worker node","[sig-storage] Volume Placement test back to back pod creation and deletion with different volume sources on the same worker node","[sig-storage] Volumes ConfigMap should be mountable","[sig-storage] vsphere statefulset vsphere statefulset testing","[sig-storage] Zone Support Verify a pod fails to get scheduled when conflicting volume topology (allowedTopologies) and pod scheduling constraints(nodeSelector) are specified","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on allowed zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on a VSAN capability, datastore and compatible zone specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in the storage class. (No shared datastores exist among both zones)","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and datastore specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones, datastore and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with allowedTopologies","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with multiple allowedTopologies","[sig-storage] Zone Support Verify a pod is created on a non-Workspace zone and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a PVC creation fails when multiple zones are specified in the storage class without shared datastores among the zones in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify dynamically created pv with allowed zones specified in storage class, shows the right zone information on its labels","[sig-storage] Zone Support Verify dynamically created pv with multiple zones specified in the storage class, shows both the zones on its labels","[sig-storage] Zone Support Verify PVC creation fails if no zones are specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only datastore is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only storage policy is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if the availability zone specified in the storage class have no shared datastores under it.","[sig-storage] Zone Support Verify PVC creation with an invalid VSAN capability along with a compatible zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with compatible policy and datastore without any zones specified in the storage class fails (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation with incompatible datastore and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storage policy along with compatible zone and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storagePolicy and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible zone along with compatible storagePolicy and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with invalid zone specified in storage class fails",null]},{"endpoint":"createCoreV1NamespacedBinding","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/bindings","description":"create a Binding","kind":"Binding","version":"v1","group":"","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps","description":"create a ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volumes ConfigMap should be mountable",null]},{"endpoint":"createCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints","description":"create Endpoints","kind":"Endpoints","version":"v1","group":"","action":"post","tested":true,"conf_tested":false,"tests":["[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"endpoint":"createCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events","description":"create an Event","kind":"Event","version":"v1","group":"","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges","description":"create a LimitRange","kind":"LimitRange","version":"v1","group":"","action":"post","tested":true,"conf_tested":false,"tests":["[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.",null]},{"endpoint":"createCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims","description":"create a PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"post","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately",null]},{"endpoint":"createCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods","description":"create a Pod","kind":"Pod","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController should update PodDisruptionBudget status","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Network should set TCP CLOSE_WAIT timeout","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volumes ConfigMap should be mountable",null]},{"endpoint":"createCoreV1NamespacedPodBinding","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/binding","description":"create binding of a Pod","kind":"Binding","version":"v1","group":"","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createCoreV1NamespacedPodEviction","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/eviction","description":"create eviction of a Pod","kind":"Eviction","version":"v1beta1","group":"policy","action":"post","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it"]},{"endpoint":"createCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates","description":"create a PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"post","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls"]},{"endpoint":"createCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers","description":"create a ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name",null]},{"endpoint":"createCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas","description":"create a ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]",null]},{"endpoint":"createCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets","description":"create a Secret","kind":"Secret","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]",null]},{"endpoint":"createCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services","description":"create a Service","kind":"Service","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume",null]},{"endpoint":"createCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts","description":"create a ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume",null]},{"endpoint":"createCoreV1NamespacedServiceAccountToken","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts/{name}/token","description":"create token of a ServiceAccount","kind":"TokenRequest","version":"v1","group":"authentication.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes","description":"create a Node","kind":"Node","version":"v1","group":"","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes","description":"create a PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"post","tested":true,"conf_tested":false,"tests":["[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately",null]},{"endpoint":"createNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies","description":"create a NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles","description":"create a ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2",null]},{"endpoint":"createRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings","description":"create a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"endpoint":"createRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles","description":"create a Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"post","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume",null]},{"endpoint":"createRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings","description":"create a RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"post","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should update PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API should support building a client with a CSR","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl alpha client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl rolling-update should support rolling-update to same image  [Conformance]","[sig-cli] Kubectl client Kubectl run","[sig-cli] Kubectl client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Kubectl run default should create an rc or deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run deployment should create a deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run job should create a job from an image when restart is OnFailure  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should do a rolling update of a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Cadvisor should be healthy on every node.","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: udp","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: udp","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PersistentVolumes:vsphere should test that deleting a PVC before the pod does not cause pod deletion to fail on vsphere volume detach","[sig-storage] PersistentVolumes:vsphere should test that deleting the Namespace of a PVC and Pod causes the successful detach of vsphere volume","[sig-storage] PersistentVolumes:vsphere should test that deleting the PV before the pod does not cause pod deletion to fail on vspehre volume detach","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volume Placement should create and delete pod with multiple volumes from different datastore","[sig-storage] Volume Placement should create and delete pod with multiple volumes from same datastore","[sig-storage] Volume Placement should create and delete pod with the same volume source attach/detach to different worker nodes","[sig-storage] Volume Placement should create and delete pod with the same volume source on the same worker node","[sig-storage] Volume Placement test back to back pod creation and deletion with different volume sources on the same worker node","[sig-storage] Volumes ConfigMap should be mountable","[sig-storage] vsphere statefulset vsphere statefulset testing","[sig-storage] Zone Support Verify a pod fails to get scheduled when conflicting volume topology (allowedTopologies) and pod scheduling constraints(nodeSelector) are specified","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on allowed zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on a VSAN capability, datastore and compatible zone specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in the storage class. (No shared datastores exist among both zones)","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and datastore specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones, datastore and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with allowedTopologies","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with multiple allowedTopologies","[sig-storage] Zone Support Verify a pod is created on a non-Workspace zone and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a PVC creation fails when multiple zones are specified in the storage class without shared datastores among the zones in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify dynamically created pv with allowed zones specified in storage class, shows the right zone information on its labels","[sig-storage] Zone Support Verify dynamically created pv with multiple zones specified in the storage class, shows both the zones on its labels","[sig-storage] Zone Support Verify PVC creation fails if no zones are specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only datastore is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only storage policy is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if the availability zone specified in the storage class have no shared datastores under it.","[sig-storage] Zone Support Verify PVC creation with an invalid VSAN capability along with a compatible zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with compatible policy and datastore without any zones specified in the storage class fails (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation with incompatible datastore and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storage policy along with compatible zone and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storagePolicy and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible zone along with compatible storagePolicy and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with invalid zone specified in storage class fails",null]},{"endpoint":"createSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses","description":"create a PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"post","tested":true,"conf_tested":false,"tests":["[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path",null]},{"endpoint":"createStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes","description":"create a CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses","description":"create a StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"post","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2",null]},{"endpoint":"createStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments","description":"create a VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAdmissionregistrationV1CollectionMutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations","description":"delete collection of MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]"]},{"endpoint":"deleteAdmissionregistrationV1CollectionValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations","description":"delete collection of ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]"]},{"endpoint":"deleteAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}","description":"delete a MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]"]},{"endpoint":"deleteAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}","description":"delete a ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]"]},{"endpoint":"deleteApiextensionsV1CollectionCustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions","description":"delete collection of CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]"]},{"endpoint":"deleteApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}","description":"delete a CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema"]},{"endpoint":"deleteApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}","description":"delete an APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]",null]},{"endpoint":"deleteApiregistrationV1CollectionAPIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices","description":"delete collection of APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1CollectionNamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions","description":"delete collection of ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1CollectionNamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets","description":"delete collection of DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1CollectionNamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments","description":"delete collection of Deployment","kind":"Deployment","version":"v1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1CollectionNamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets","description":"delete collection of ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1CollectionNamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets","description":"delete collection of StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}","description":"delete a ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}","description":"delete a DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}","description":"delete a Deployment","kind":"Deployment","version":"v1","group":"apps","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"endpoint":"deleteAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}","description":"delete a ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]",null]},{"endpoint":"deleteAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}","description":"delete a StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume"]},{"endpoint":"deleteAutoscalingV1CollectionNamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers","description":"delete collection of HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"delete a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteBatchV1CollectionNamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs","description":"delete collection of Job","kind":"Job","version":"v1","group":"batch","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}","description":"delete a Job","kind":"Job","version":"v1","group":"batch","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should remove pods when job is deleted","[sig-cli] Kubectl client Simple pod should support inline execution and attach",null]},{"endpoint":"deleteCoordinationV1CollectionNamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases","description":"delete collection of Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"deletecollection","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]",null]},{"endpoint":"deleteCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}","description":"delete a Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]"]},{"endpoint":"deleteCoreV1CollectionNamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps","description":"delete collection of ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints","description":"delete collection of Endpoints","kind":"Endpoints","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events","description":"delete collection of Event","kind":"Event","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges","description":"delete collection of LimitRange","kind":"LimitRange","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims","description":"delete collection of PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods","description":"delete collection of Pod","kind":"Pod","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates","description":"delete collection of PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers","description":"delete collection of ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas","description":"delete collection of ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets","description":"delete collection of Secret","kind":"Secret","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts","description":"delete collection of ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionNode","level":"stable","category":"core","path":"/api/v1/nodes","description":"delete collection of Node","kind":"Node","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1CollectionPersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes","description":"delete collection of PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces/{name}","description":"delete a Namespace","kind":"Namespace","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should update PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API should support building a client with a CSR","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl alpha client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl rolling-update should support rolling-update to same image  [Conformance]","[sig-cli] Kubectl client Kubectl run","[sig-cli] Kubectl client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Kubectl run default should create an rc or deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run deployment should create a deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run job should create a job from an image when restart is OnFailure  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should do a rolling update of a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Cadvisor should be healthy on every node.","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: udp","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: udp","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PersistentVolumes:vsphere should test that deleting a PVC before the pod does not cause pod deletion to fail on vsphere volume detach","[sig-storage] PersistentVolumes:vsphere should test that deleting the Namespace of a PVC and Pod causes the successful detach of vsphere volume","[sig-storage] PersistentVolumes:vsphere should test that deleting the PV before the pod does not cause pod deletion to fail on vspehre volume detach","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volume Placement should create and delete pod with multiple volumes from different datastore","[sig-storage] Volume Placement should create and delete pod with multiple volumes from same datastore","[sig-storage] Volume Placement should create and delete pod with the same volume source attach/detach to different worker nodes","[sig-storage] Volume Placement should create and delete pod with the same volume source on the same worker node","[sig-storage] Volume Placement test back to back pod creation and deletion with different volume sources on the same worker node","[sig-storage] Volumes ConfigMap should be mountable","[sig-storage] vsphere statefulset vsphere statefulset testing","[sig-storage] Zone Support Verify a pod fails to get scheduled when conflicting volume topology (allowedTopologies) and pod scheduling constraints(nodeSelector) are specified","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on allowed zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on a VSAN capability, datastore and compatible zone specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in the storage class. (No shared datastores exist among both zones)","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and datastore specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones, datastore and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with allowedTopologies","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with multiple allowedTopologies","[sig-storage] Zone Support Verify a pod is created on a non-Workspace zone and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a PVC creation fails when multiple zones are specified in the storage class without shared datastores among the zones in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify dynamically created pv with allowed zones specified in storage class, shows the right zone information on its labels","[sig-storage] Zone Support Verify dynamically created pv with multiple zones specified in the storage class, shows both the zones on its labels","[sig-storage] Zone Support Verify PVC creation fails if no zones are specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only datastore is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only storage policy is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if the availability zone specified in the storage class have no shared datastores under it.","[sig-storage] Zone Support Verify PVC creation with an invalid VSAN capability along with a compatible zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with compatible policy and datastore without any zones specified in the storage class fails (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation with incompatible datastore and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storage policy along with compatible zone and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storagePolicy and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible zone along with compatible storagePolicy and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with invalid zone specified in storage class fails"]},{"endpoint":"deleteCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps/{name}","description":"delete a ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Volumes ConfigMap should be mountable"]},{"endpoint":"deleteCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints/{name}","description":"delete Endpoints","kind":"Endpoints","version":"v1","group":"","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"endpoint":"deleteCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events/{name}","description":"delete an Event","kind":"Event","version":"v1","group":"","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges/{name}","description":"delete a LimitRange","kind":"LimitRange","version":"v1","group":"","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied."]},{"endpoint":"deleteCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}","description":"delete a PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately"]},{"endpoint":"deleteCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}","description":"delete a Pod","kind":"Pod","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volumes ConfigMap should be mountable",null]},{"endpoint":"deleteCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates/{name}","description":"delete a PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}","description":"delete a ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]",null]},{"endpoint":"deleteCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}","description":"delete a ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource."]},{"endpoint":"deleteCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets/{name}","description":"delete a Secret","kind":"Secret","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]",null]},{"endpoint":"deleteCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}","description":"delete a Service","kind":"Service","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume",null]},{"endpoint":"deleteCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts/{name}","description":"delete a ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume"]},{"endpoint":"deleteCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes/{name}","description":"delete a Node","kind":"Node","version":"v1","group":"","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}","description":"delete a PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately",null]},{"endpoint":"deleteNetworkingV1CollectionNamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies","description":"delete collection of NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}","description":"delete a NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}","description":"delete a ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume"]},{"endpoint":"deleteRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}","description":"delete a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod"]},{"endpoint":"deleteRbacAuthorizationV1CollectionClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles","description":"delete collection of ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1CollectionClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings","description":"delete collection of ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1CollectionNamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles","description":"delete collection of Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1CollectionNamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings","description":"delete collection of RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}","description":"delete a Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume"]},{"endpoint":"deleteRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}","description":"delete a RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"delete","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume"]},{"endpoint":"deleteSchedulingV1CollectionPriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses","description":"delete collection of PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses/{name}","description":"delete a PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path"]},{"endpoint":"deleteStorageV1CollectionCSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes","description":"delete collection of CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1CollectionStorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses","description":"delete collection of StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1CollectionVolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments","description":"delete collection of VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes/{name}","description":"delete a CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses/{name}","description":"delete a StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2"]},{"endpoint":"deleteStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}","description":"delete a VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getAdmissionregistrationAPIGroup","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]"]},{"endpoint":"getAdmissionregistrationV1APIResources","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getApiextensionsAPIGroup","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]"]},{"endpoint":"getApiextensionsV1APIResources","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getApiregistrationAPIGroup","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getApiregistrationV1APIResources","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getAPIVersions","level":"stable","category":"apis","path":"/apis/","description":"get available API versions","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getAppsAPIGroup","level":"stable","category":"apps","path":"/apis/apps/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getAppsV1APIResources","level":"stable","category":"apps","path":"/apis/apps/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getAuditregistrationAPIGroup","level":"stable","category":"auditregistration","path":"/apis/auditregistration.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getAuthenticationAPIGroup","level":"stable","category":"authentication","path":"/apis/authentication.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getAuthenticationV1APIResources","level":"stable","category":"authentication","path":"/apis/authentication.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getAuthorizationAPIGroup","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getAuthorizationV1APIResources","level":"stable","category":"authorization","path":"/apis/authorization.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getAutoscalingAPIGroup","level":"stable","category":"autoscaling","path":"/apis/autoscaling/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getAutoscalingV1APIResources","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getBatchAPIGroup","level":"stable","category":"batch","path":"/apis/batch/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getBatchV1APIResources","level":"stable","category":"batch","path":"/apis/batch/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getCertificatesAPIGroup","level":"stable","category":"certificates","path":"/apis/certificates.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getCodeVersion","level":"stable","category":"version","path":"/version/","description":"get the code version","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getCoordinationAPIGroup","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getCoordinationV1APIResources","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getCoreAPIVersions","level":"stable","category":"core","path":"/api/","description":"get available API versions","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getCoreV1APIResources","level":"stable","category":"core","path":"/api/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getDiscoveryAPIGroup","level":"stable","category":"discovery","path":"/apis/discovery.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getEventsAPIGroup","level":"stable","category":"events","path":"/apis/events.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getExtensionsAPIGroup","level":"stable","category":"extensions","path":"/apis/extensions/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getFlowcontrolApiserverAPIGroup","level":"stable","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getNetworkingAPIGroup","level":"stable","category":"networking","path":"/apis/networking.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getNetworkingV1APIResources","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getNodeAPIGroup","level":"stable","category":"node","path":"/apis/node.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getPolicyAPIGroup","level":"stable","category":"policy","path":"/apis/policy/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getRbacAuthorizationAPIGroup","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getRbacAuthorizationV1APIResources","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getSchedulingAPIGroup","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getSchedulingV1APIResources","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getSettingsAPIGroup","level":"stable","category":"settings","path":"/apis/settings.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getStorageAPIGroup","level":"stable","category":"storage","path":"/apis/storage.k8s.io/","description":"get information of a group","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getStorageV1APIResources","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"listAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations","description":"list or watch objects of kind MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]",null]},{"endpoint":"listAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations","description":"list or watch objects of kind ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]",null]},{"endpoint":"listApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions","description":"list or watch objects of kind CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]",null]},{"endpoint":"listApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices","description":"list or watch objects of kind APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1ControllerRevisionForAllNamespaces","level":"stable","category":"apps","path":"/apis/apps/v1/controllerrevisions","description":"list or watch objects of kind ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1DaemonSetForAllNamespaces","level":"stable","category":"apps","path":"/apis/apps/v1/daemonsets","description":"list or watch objects of kind DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1DeploymentForAllNamespaces","level":"stable","category":"apps","path":"/apis/apps/v1/deployments","description":"list or watch objects of kind Deployment","kind":"Deployment","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions","description":"list or watch objects of kind ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets","description":"list or watch objects of kind DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"list","tested":true,"conf_tested":false,"tests":["",null]},{"endpoint":"listAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments","description":"list or watch objects of kind Deployment","kind":"Deployment","version":"v1","group":"apps","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios",null]},{"endpoint":"listAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets","description":"list or watch objects of kind ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"list","tested":true,"conf_tested":true,"tests":["","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"endpoint":"listAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets","description":"list or watch objects of kind StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"list","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]",null]},{"endpoint":"listAppsV1ReplicaSetForAllNamespaces","level":"stable","category":"apps","path":"/apis/apps/v1/replicasets","description":"list or watch objects of kind ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1StatefulSetForAllNamespaces","level":"stable","category":"apps","path":"/apis/apps/v1/statefulsets","description":"list or watch objects of kind StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAutoscalingV1HorizontalPodAutoscalerForAllNamespaces","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listBatchV1JobForAllNamespaces","level":"stable","category":"batch","path":"/apis/batch/v1/jobs","description":"list or watch objects of kind Job","kind":"Job","version":"v1","group":"batch","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs","description":"list or watch objects of kind Job","kind":"Job","version":"v1","group":"batch","action":"list","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently",null]},{"endpoint":"listCoordinationV1LeaseForAllNamespaces","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/leases","description":"list or watch objects of kind Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases","description":"list or watch objects of kind Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set",null]},{"endpoint":"listCoreV1ComponentStatus","level":"stable","category":"core","path":"/api/v1/componentstatuses","description":"list objects of kind ComponentStatus","kind":"ComponentStatus","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1ConfigMapForAllNamespaces","level":"stable","category":"core","path":"/api/v1/configmaps","description":"list or watch objects of kind ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1EndpointsForAllNamespaces","level":"stable","category":"core","path":"/api/v1/endpoints","description":"list or watch objects of kind Endpoints","kind":"Endpoints","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1EventForAllNamespaces","level":"stable","category":"core","path":"/api/v1/events","description":"list or watch objects of kind Event","kind":"Event","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1LimitRangeForAllNamespaces","level":"stable","category":"core","path":"/api/v1/limitranges","description":"list or watch objects of kind LimitRange","kind":"LimitRange","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces","description":"list or watch objects of kind Namespace","kind":"Namespace","version":"v1","group":"","action":"list","tested":true,"conf_tested":false,"tests":["[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk",null]},{"endpoint":"listCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps","description":"list or watch objects of kind ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]",null]},{"endpoint":"listCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints","description":"list or watch objects of kind Endpoints","kind":"Endpoints","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]",null]},{"endpoint":"listCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events","description":"list or watch objects of kind Event","kind":"Event","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges","description":"list or watch objects of kind LimitRange","kind":"LimitRange","version":"v1","group":"","action":"list","tested":true,"conf_tested":false,"tests":["[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.",null]},{"endpoint":"listCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims","description":"list or watch objects of kind PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]",null]},{"endpoint":"listCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods","description":"list or watch objects of kind Pod","kind":"Pod","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should update PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl run default should create an rc or deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run deployment should create a deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]",null]},{"endpoint":"listCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates","description":"list or watch objects of kind PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"list","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls",null]},{"endpoint":"listCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers","description":"list or watch objects of kind ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl rolling-update should support rolling-update to same image  [Conformance]",null]},{"endpoint":"listCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas","description":"list or watch objects of kind ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]",null]},{"endpoint":"listCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets","description":"list or watch objects of kind Secret","kind":"Secret","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]",null]},{"endpoint":"listCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services","description":"list or watch objects of kind Service","kind":"Service","version":"v1","group":"","action":"list","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json,application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf,application/json\"",null]},{"endpoint":"listCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts","description":"list or watch objects of kind ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should update PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API should support building a client with a CSR","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl alpha client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl rolling-update should support rolling-update to same image  [Conformance]","[sig-cli] Kubectl client Kubectl run","[sig-cli] Kubectl client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Kubectl run default should create an rc or deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run deployment should create a deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run job should create a job from an image when restart is OnFailure  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should do a rolling update of a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Cadvisor should be healthy on every node.","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: udp","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: udp","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PersistentVolumes:vsphere should test that deleting a PVC before the pod does not cause pod deletion to fail on vsphere volume detach","[sig-storage] PersistentVolumes:vsphere should test that deleting the Namespace of a PVC and Pod causes the successful detach of vsphere volume","[sig-storage] PersistentVolumes:vsphere should test that deleting the PV before the pod does not cause pod deletion to fail on vspehre volume detach","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volume Placement should create and delete pod with multiple volumes from different datastore","[sig-storage] Volume Placement should create and delete pod with multiple volumes from same datastore","[sig-storage] Volume Placement should create and delete pod with the same volume source attach/detach to different worker nodes","[sig-storage] Volume Placement should create and delete pod with the same volume source on the same worker node","[sig-storage] Volume Placement test back to back pod creation and deletion with different volume sources on the same worker node","[sig-storage] Volumes ConfigMap should be mountable","[sig-storage] vsphere statefulset vsphere statefulset testing","[sig-storage] Zone Support Verify a pod fails to get scheduled when conflicting volume topology (allowedTopologies) and pod scheduling constraints(nodeSelector) are specified","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on allowed zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on a VSAN capability, datastore and compatible zone specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in the storage class. (No shared datastores exist among both zones)","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and datastore specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones, datastore and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with allowedTopologies","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with multiple allowedTopologies","[sig-storage] Zone Support Verify a pod is created on a non-Workspace zone and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a PVC creation fails when multiple zones are specified in the storage class without shared datastores among the zones in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify dynamically created pv with allowed zones specified in storage class, shows the right zone information on its labels","[sig-storage] Zone Support Verify dynamically created pv with multiple zones specified in the storage class, shows both the zones on its labels","[sig-storage] Zone Support Verify PVC creation fails if no zones are specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only datastore is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only storage policy is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if the availability zone specified in the storage class have no shared datastores under it.","[sig-storage] Zone Support Verify PVC creation with an invalid VSAN capability along with a compatible zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with compatible policy and datastore without any zones specified in the storage class fails (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation with incompatible datastore and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storage policy along with compatible zone and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storagePolicy and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible zone along with compatible storagePolicy and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with invalid zone specified in storage class fails",null]},{"endpoint":"listCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes","description":"list or watch objects of kind Node","kind":"Node","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json,application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf,application/json\"","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should update PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API should support building a client with a CSR","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl alpha client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl rolling-update should support rolling-update to same image  [Conformance]","[sig-cli] Kubectl client Kubectl run","[sig-cli] Kubectl client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Kubectl run default should create an rc or deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run deployment should create a deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run job should create a job from an image when restart is OnFailure  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should do a rolling update of a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Cadvisor should be healthy on every node.","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: udp","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: udp","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PersistentVolumes:vsphere should test that deleting a PVC before the pod does not cause pod deletion to fail on vsphere volume detach","[sig-storage] PersistentVolumes:vsphere should test that deleting the Namespace of a PVC and Pod causes the successful detach of vsphere volume","[sig-storage] PersistentVolumes:vsphere should test that deleting the PV before the pod does not cause pod deletion to fail on vspehre volume detach","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volume Placement should create and delete pod with multiple volumes from different datastore","[sig-storage] Volume Placement should create and delete pod with multiple volumes from same datastore","[sig-storage] Volume Placement should create and delete pod with the same volume source attach/detach to different worker nodes","[sig-storage] Volume Placement should create and delete pod with the same volume source on the same worker node","[sig-storage] Volume Placement test back to back pod creation and deletion with different volume sources on the same worker node","[sig-storage] Volumes ConfigMap should be mountable","[sig-storage] vsphere statefulset vsphere statefulset testing","[sig-storage] Zone Support Verify a pod fails to get scheduled when conflicting volume topology (allowedTopologies) and pod scheduling constraints(nodeSelector) are specified","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on allowed zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on a VSAN capability, datastore and compatible zone specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in the storage class. (No shared datastores exist among both zones)","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and datastore specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones, datastore and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with allowedTopologies","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with multiple allowedTopologies","[sig-storage] Zone Support Verify a pod is created on a non-Workspace zone and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a PVC creation fails when multiple zones are specified in the storage class without shared datastores among the zones in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify dynamically created pv with allowed zones specified in storage class, shows the right zone information on its labels","[sig-storage] Zone Support Verify dynamically created pv with multiple zones specified in the storage class, shows both the zones on its labels","[sig-storage] Zone Support Verify PVC creation fails if no zones are specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only datastore is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only storage policy is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if the availability zone specified in the storage class have no shared datastores under it.","[sig-storage] Zone Support Verify PVC creation with an invalid VSAN capability along with a compatible zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with compatible policy and datastore without any zones specified in the storage class fails (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation with incompatible datastore and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storage policy along with compatible zone and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storagePolicy and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible zone along with compatible storagePolicy and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with invalid zone specified in storage class fails",null]},{"endpoint":"listCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes","description":"list or watch objects of kind PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"list","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]",null]},{"endpoint":"listCoreV1PersistentVolumeClaimForAllNamespaces","level":"stable","category":"core","path":"/api/v1/persistentvolumeclaims","description":"list or watch objects of kind PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1PodForAllNamespaces","level":"stable","category":"core","path":"/api/v1/pods","description":"list or watch objects of kind Pod","kind":"Pod","version":"v1","group":"","action":"list","tested":true,"conf_tested":false,"tests":["[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error",null]},{"endpoint":"listCoreV1PodTemplateForAllNamespaces","level":"stable","category":"core","path":"/api/v1/podtemplates","description":"list or watch objects of kind PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1ReplicationControllerForAllNamespaces","level":"stable","category":"core","path":"/api/v1/replicationcontrollers","description":"list or watch objects of kind ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1ResourceQuotaForAllNamespaces","level":"stable","category":"core","path":"/api/v1/resourcequotas","description":"list or watch objects of kind ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1SecretForAllNamespaces","level":"stable","category":"core","path":"/api/v1/secrets","description":"list or watch objects of kind Secret","kind":"Secret","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1ServiceAccountForAllNamespaces","level":"stable","category":"core","path":"/api/v1/serviceaccounts","description":"list or watch objects of kind ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoreV1ServiceForAllNamespaces","level":"stable","category":"core","path":"/api/v1/services","description":"list or watch objects of kind Service","kind":"Service","version":"v1","group":"","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies","description":"list or watch objects of kind NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listNetworkingV1NetworkPolicyForAllNamespaces","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/networkpolicies","description":"list or watch objects of kind NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles","description":"list or watch objects of kind ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]",null]},{"endpoint":"listRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings","description":"list or watch objects of kind ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1RoleBindingForAllNamespaces","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1RoleForAllNamespaces","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses","description":"list or watch objects of kind PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes","description":"list or watch objects of kind CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses","description":"list or watch objects of kind StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"list","tested":true,"conf_tested":false,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable",null]},{"endpoint":"listStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments","description":"list or watch objects of kind VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"logFileHandler","level":"stable","category":"logs","path":"/logs/{logpath}","description":null,"kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"logFileListHandler","level":"stable","category":"logs","path":"/logs/","description":null,"kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":false,"tests":["[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services"]},{"endpoint":"patchAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}","description":"partially update the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]"]},{"endpoint":"patchAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}","description":"partially update the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]"]},{"endpoint":"patchApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}","description":"partially update the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]"]},{"endpoint":"patchApiextensionsV1CustomResourceDefinitionStatus","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status","description":"partially update status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]"]},{"endpoint":"patchApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}","description":"partially update the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchApiregistrationV1APIServiceStatus","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}/status","description":"partially update status of the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}","description":"partially update the specified ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}","description":"partially update the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedDaemonSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status","description":"partially update status of the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}","description":"partially update the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedDeploymentScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale","description":"partially update scale of the specified Deployment","kind":"Scale","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedDeploymentStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status","description":"partially update status of the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}","description":"partially update the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedReplicaSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale","description":"partially update scale of the specified ReplicaSet","kind":"Scale","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedReplicaSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status","description":"partially update status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}","description":"partially update the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedStatefulSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale","description":"partially update scale of the specified StatefulSet","kind":"Scale","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1NamespacedStatefulSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status","description":"partially update status of the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"partially update the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAutoscalingV1NamespacedHorizontalPodAutoscalerStatus","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"partially update status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}","description":"partially update the specified Job","kind":"Job","version":"v1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchBatchV1NamespacedJobStatus","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status","description":"partially update status of the specified Job","kind":"Job","version":"v1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}","description":"partially update the specified Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"patch","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]"]},{"endpoint":"patchCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces/{name}","description":"partially update the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps/{name}","description":"partially update the specified ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]"]},{"endpoint":"patchCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints/{name}","description":"partially update the specified Endpoints","kind":"Endpoints","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events/{name}","description":"partially update the specified Event","kind":"Event","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges/{name}","description":"partially update the specified LimitRange","kind":"LimitRange","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}","description":"partially update the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedPersistentVolumeClaimStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status","description":"partially update status of the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}","description":"partially update the specified Pod","kind":"Pod","version":"v1","group":"","action":"patch","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]",null]},{"endpoint":"patchCoreV1NamespacedPodStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/status","description":"partially update status of the specified Pod","kind":"Pod","version":"v1","group":"","action":"patch","tested":true,"conf_tested":false,"tests":["[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]",null]},{"endpoint":"patchCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates/{name}","description":"partially update the specified PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}","description":"partially update the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedReplicationControllerScale","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale","description":"partially update scale of the specified ReplicationController","kind":"Scale","version":"v1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedReplicationControllerStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status","description":"partially update status of the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}","description":"partially update the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedResourceQuotaStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}/status","description":"partially update status of the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets/{name}","description":"partially update the specified Secret","kind":"Secret","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}","description":"partially update the specified Service","kind":"Service","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts/{name}","description":"partially update the specified ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespacedServiceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/status","description":"partially update status of the specified Service","kind":"Service","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1NamespaceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{name}/status","description":"partially update status of the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes/{name}","description":"partially update the specified Node","kind":"Node","version":"v1","group":"","action":"patch","tested":true,"conf_tested":false,"tests":["[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"endpoint":"patchCoreV1NodeStatus","level":"stable","category":"core","path":"/api/v1/nodes/{name}/status","description":"partially update status of the specified Node","kind":"Node","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}","description":"partially update the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoreV1PersistentVolumeStatus","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}/status","description":"partially update status of the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}","description":"partially update the specified NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}","description":"partially update the specified ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}","description":"partially update the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}","description":"partially update the specified Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}","description":"partially update the specified RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses/{name}","description":"partially update the specified PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes/{name}","description":"partially update the specified CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses/{name}","description":"partially update the specified StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}","description":"partially update the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchStorageV1VolumeAttachmentStatus","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}/status","description":"partially update status of the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}","description":"read the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]"]},{"endpoint":"readAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}","description":"read the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]"]},{"endpoint":"readApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}","description":"read the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]"]},{"endpoint":"readApiextensionsV1CustomResourceDefinitionStatus","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status","description":"read status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]"]},{"endpoint":"readApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}","description":"read the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]",null]},{"endpoint":"readApiregistrationV1APIServiceStatus","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}/status","description":"read status of the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}","description":"read the specified ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}","description":"read the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1NamespacedDaemonSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status","description":"read status of the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}","description":"read the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-cli] Kubectl client Kubectl run deployment should create a deployment from an image  [Conformance]","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"endpoint":"readAppsV1NamespacedDeploymentScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale","description":"read scale of the specified Deployment","kind":"Scale","version":"v1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1NamespacedDeploymentStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status","description":"read status of the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}","description":"read the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path",null]},{"endpoint":"readAppsV1NamespacedReplicaSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale","description":"read scale of the specified ReplicaSet","kind":"Scale","version":"v1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1NamespacedReplicaSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status","description":"read status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}","description":"read the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]",null]},{"endpoint":"readAppsV1NamespacedStatefulSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale","description":"read scale of the specified StatefulSet","kind":"Scale","version":"v1","group":"autoscaling","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]"]},{"endpoint":"readAppsV1NamespacedStatefulSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status","description":"read status of the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"read the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAutoscalingV1NamespacedHorizontalPodAutoscalerStatus","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"read status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}","description":"read the specified Job","kind":"Job","version":"v1","group":"batch","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-cli] Kubectl client Kubectl run","[sig-cli] Kubectl client Kubectl run job should create a job from an image when restart is OnFailure  [Conformance]",null]},{"endpoint":"readBatchV1NamespacedJobStatus","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status","description":"read status of the specified Job","kind":"Job","version":"v1","group":"batch","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}","description":"read the specified Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently",null]},{"endpoint":"readCoreV1ComponentStatus","level":"stable","category":"core","path":"/api/v1/componentstatuses/{name}","description":"read the specified ComponentStatus","kind":"ComponentStatus","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces/{name}","description":"read the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Lease lease API should be available [Conformance]","[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] crictl should be able to run crictl on the node","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should update PodDisruptionBudget status","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] Job should delete a job [Conformance]","[sig-apps] Job should fail to exceed backoffLimit","[sig-apps] Job should fail when exceeds active deadline","[sig-apps] Job should remove pods when job is deleted","[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","[sig-apps] Job should run a job to completion when tasks succeed","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] Certificates API should support building a client with a CSR","[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-cli] Kubectl alpha client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl rolling-update should support rolling-update to same image  [Conformance]","[sig-cli] Kubectl client Kubectl run","[sig-cli] Kubectl client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Kubectl run default should create an rc or deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run deployment should create a deployment from an image  [Conformance]","[sig-cli] Kubectl client Kubectl run job should create a job from an image when restart is OnFailure  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","[sig-cli] Kubectl client Proxy server should support","[sig-cli] Kubectl client Proxy server should support proxy with","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should do a rolling update of a replication controller  [Conformance]","[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-instrumentation] Cadvisor should be healthy on every node.","[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","[sig-network] Network should set TCP CLOSE_WAIT timeout","[sig-network] Proxy version v1 should proxy logs on node using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource  [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Service endpoints latency should not be very high  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should prevent NodePort collisions","[sig-network] Services should provide secure master service  [Conformance]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: udp","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: http","[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: udp","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","[sig-node] ConfigMap should update ConfigMap successfully","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.","[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PersistentVolumes:vsphere should test that deleting a PVC before the pod does not cause pod deletion to fail on vsphere volume detach","[sig-storage] PersistentVolumes:vsphere should test that deleting the Namespace of a PVC and Pod causes the successful detach of vsphere volume","[sig-storage] PersistentVolumes:vsphere should test that deleting the PV before the pod does not cause pod deletion to fail on vspehre volume detach","[sig-storage] Pod Disks should be able to delete a non-existent PD without error","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volume limits should verify that all nodes have volume limits","[sig-storage] Volume Placement should create and delete pod with multiple volumes from different datastore","[sig-storage] Volume Placement should create and delete pod with multiple volumes from same datastore","[sig-storage] Volume Placement should create and delete pod with the same volume source attach/detach to different worker nodes","[sig-storage] Volume Placement should create and delete pod with the same volume source on the same worker node","[sig-storage] Volume Placement test back to back pod creation and deletion with different volume sources on the same worker node","[sig-storage] Volumes ConfigMap should be mountable","[sig-storage] vsphere statefulset vsphere statefulset testing","[sig-storage] Zone Support Verify a pod fails to get scheduled when conflicting volume topology (allowedTopologies) and pod scheduling constraints(nodeSelector) are specified","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on allowed zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on a VSAN capability, datastore and compatible zone specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in the storage class. (No shared datastores exist among both zones)","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and datastore specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones, datastore and storage policy specified in storage class","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with allowedTopologies","[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with multiple allowedTopologies","[sig-storage] Zone Support Verify a pod is created on a non-Workspace zone and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","[sig-storage] Zone Support Verify a PVC creation fails when multiple zones are specified in the storage class without shared datastores among the zones in waitForFirstConsumer binding mode","[sig-storage] Zone Support Verify dynamically created pv with allowed zones specified in storage class, shows the right zone information on its labels","[sig-storage] Zone Support Verify dynamically created pv with multiple zones specified in the storage class, shows both the zones on its labels","[sig-storage] Zone Support Verify PVC creation fails if no zones are specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only datastore is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if only storage policy is specified in the storage class (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation fails if the availability zone specified in the storage class have no shared datastores under it.","[sig-storage] Zone Support Verify PVC creation with an invalid VSAN capability along with a compatible zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with compatible policy and datastore without any zones specified in the storage class fails (No shared datastores exist among all the nodes)","[sig-storage] Zone Support Verify PVC creation with incompatible datastore and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storage policy along with compatible zone and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible storagePolicy and zone combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with incompatible zone along with compatible storagePolicy and datastore combination specified in storage class fails","[sig-storage] Zone Support Verify PVC creation with invalid zone specified in storage class fails",null]},{"endpoint":"readCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps/{name}","description":"read the specified ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-node] ConfigMap should update ConfigMap successfully",null]},{"endpoint":"readCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints/{name}","description":"read the specified Endpoints","kind":"Endpoints","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-network] Firewall rule should have correct firewall rules for e2e cluster","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]",null]},{"endpoint":"readCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events/{name}","description":"read the specified Event","kind":"Event","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges/{name}","description":"read the specified LimitRange","kind":"LimitRange","version":"v1","group":"","action":"get","tested":true,"conf_tested":false,"tests":["[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.",null]},{"endpoint":"readCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}","description":"read the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"get","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately",null]},{"endpoint":"readCoreV1NamespacedPersistentVolumeClaimStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status","description":"read status of the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}","description":"read the specified Pod","kind":"Pod","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should be restarted with a local redirect http liveness probe","[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-api-machinery] Servers with support for Table transformation should return pod details","[sig-apps] Deployment deployment should delete old replica sets [Conformance]","[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] ReplicationController should serve a basic image on each replica with a private image","[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","[sig-cli] Kubectl client Simple pod should contain last line of the log","[sig-cli] Kubectl client Simple pod should handle in-cluster config","[sig-cli] Kubectl client Simple pod should return command exit codes","[sig-cli] Kubectl client Simple pod should support exec","[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","[sig-cli] Kubectl client Simple pod should support exec using resource/name","[sig-cli] Kubectl client Simple pod should support inline execution and attach","[sig-cli] Kubectl client Simple pod should support port-forward","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","[sig-network] DNS should provide DNS for services  [Conformance]","[sig-network] DNS should provide DNS for the cluster  [Conformance]","[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","[sig-network] DNS should support configurable pod resolv.conf","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Network should set TCP CLOSE_WAIT timeout","[sig-network] Services should allow pods to hairpin back to themselves through services","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to create a functioning NodePort service [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should be rejected when no endpoints exist","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","[sig-network] Services should release NodePorts on delete","[sig-network] Services should serve a basic endpoint from pods  [Conformance]","[sig-network] Services should serve multiport endpoints from pods  [Conformance]","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","[sig-storage] Flexvolumes should be mountable when attachable","[sig-storage] Flexvolumes should be mountable when non-attachable","[sig-storage] GCP Volumes GlusterFS should be mountable","[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","[sig-storage] Volumes ConfigMap should be mountable",null]},{"endpoint":"readCoreV1NamespacedPodLog","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/log","description":"read log of the specified Pod","kind":"Pod","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] HostPath should support r/w [NodeConformance]","[sig-storage] HostPath should support subPath [NodeConformance]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]",null]},{"endpoint":"readCoreV1NamespacedPodStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/status","description":"read status of the specified Pod","kind":"Pod","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates/{name}","description":"read the specified PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}","description":"read the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-cli] Kubectl client Kubectl rolling-update should support rolling-update to same image  [Conformance]","[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]",null]},{"endpoint":"readCoreV1NamespacedReplicationControllerScale","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale","description":"read scale of the specified ReplicationController","kind":"Scale","version":"v1","group":"autoscaling","action":"get","tested":true,"conf_tested":false,"tests":["[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"readCoreV1NamespacedReplicationControllerStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status","description":"read status of the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}","description":"read the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes"]},{"endpoint":"readCoreV1NamespacedResourceQuotaStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}/status","description":"read status of the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets/{name}","description":"read the specified Secret","kind":"Secret","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]",null]},{"endpoint":"readCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}","description":"read the specified Service","kind":"Service","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json,application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf\"","[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf,application/json\"","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-network] Networking Granular Checks: Services should function for node-Service: udp","[sig-network] Networking Granular Checks: Services should function for pod-Service: http","[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","[sig-network] Networking Granular Checks: Services should update endpoints: http","[sig-network] Networking Granular Checks: Services should update endpoints: udp","[sig-network] Networking should check kube-proxy urls","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to up and down services","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name","[sig-network] Services should provide secure master service  [Conformance]",null]},{"endpoint":"readCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts/{name}","description":"read the specified ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"get","tested":true,"conf_tested":true,"tests":["[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","[sig-auth] ServiceAccounts should ensure a single API token exists","[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]",null]},{"endpoint":"readCoreV1NamespacedServiceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/status","description":"read status of the specified Service","kind":"Service","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoreV1NamespaceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{name}/status","description":"read status of the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes/{name}","description":"read the specified Node","kind":"Node","version":"v1","group":"","action":"get","tested":true,"conf_tested":false,"tests":["[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod",null]},{"endpoint":"readCoreV1NodeStatus","level":"stable","category":"core","path":"/api/v1/nodes/{name}/status","description":"read status of the specified Node","kind":"Node","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}","description":"read the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"get","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] Mounted volume expand Should verify mounted devices can be resized","[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately",null]},{"endpoint":"readCoreV1PersistentVolumeStatus","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}/status","description":"read status of the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}","description":"read the specified NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}","description":"read the specified ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}","description":"read the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}","description":"read the specified Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}","description":"read the specified RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses/{name}","description":"read the specified PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes/{name}","description":"read the specified CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses/{name}","description":"read the specified StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"get","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options",null]},{"endpoint":"readStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}","description":"read the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"get","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment",null]},{"endpoint":"readStorageV1VolumeAttachmentStatus","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}/status","description":"read status of the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAdmissionregistrationV1MutatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/mutatingwebhookconfigurations/{name}","description":"replace the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]"]},{"endpoint":"replaceAdmissionregistrationV1ValidatingWebhookConfiguration","level":"stable","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1/validatingwebhookconfigurations/{name}","description":"replace the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1","group":"admissionregistration.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]"]},{"endpoint":"replaceApiextensionsV1CustomResourceDefinition","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}","description":"replace the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]"]},{"endpoint":"replaceApiextensionsV1CustomResourceDefinitionStatus","level":"stable","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1/customresourcedefinitions/{name}/status","description":"replace status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1","group":"apiextensions.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]",null]},{"endpoint":"replaceApiregistrationV1APIService","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}","description":"replace the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceApiregistrationV1APIServiceStatus","level":"stable","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1/apiservices/{name}/status","description":"replace status of the specified APIService","kind":"APIService","version":"v1","group":"apiregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1NamespacedControllerRevision","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/controllerrevisions/{name}","description":"replace the specified ControllerRevision","kind":"ControllerRevision","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1NamespacedDaemonSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}","description":"replace the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1NamespacedDaemonSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/daemonsets/{name}/status","description":"replace status of the specified DaemonSet","kind":"DaemonSet","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1NamespacedDeployment","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}","description":"replace the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"put","tested":true,"conf_tested":true,"tests":["[sig-apps] Deployment deployment should support proportional scaling [Conformance]","[sig-apps] Deployment deployment should support rollover [Conformance]","[sig-apps] Deployment iterative rollouts should eventually progress","[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout",null]},{"endpoint":"replaceAppsV1NamespacedDeploymentScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/scale","description":"replace scale of the specified Deployment","kind":"Scale","version":"v1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1NamespacedDeploymentStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/deployments/{name}/status","description":"replace status of the specified Deployment","kind":"Deployment","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1NamespacedReplicaSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}","description":"replace the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"put","tested":true,"conf_tested":false,"tests":["[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota",null]},{"endpoint":"replaceAppsV1NamespacedReplicaSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/scale","description":"replace scale of the specified ReplicaSet","kind":"Scale","version":"v1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1NamespacedReplicaSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/replicasets/{name}/status","description":"replace status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1NamespacedStatefulSet","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}","description":"replace the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"put","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]"]},{"endpoint":"replaceAppsV1NamespacedStatefulSetScale","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/scale","description":"replace scale of the specified StatefulSet","kind":"Scale","version":"v1","group":"autoscaling","action":"put","tested":true,"conf_tested":true,"tests":["[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]"]},{"endpoint":"replaceAppsV1NamespacedStatefulSetStatus","level":"stable","category":"apps","path":"/apis/apps/v1/namespaces/{namespace}/statefulsets/{name}/status","description":"replace status of the specified StatefulSet","kind":"StatefulSet","version":"v1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAutoscalingV1NamespacedHorizontalPodAutoscaler","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"replace the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus","level":"stable","category":"autoscaling","path":"/apis/autoscaling/v1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"replace status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceBatchV1NamespacedJob","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}","description":"replace the specified Job","kind":"Job","version":"v1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceBatchV1NamespacedJobStatus","level":"stable","category":"batch","path":"/apis/batch/v1/namespaces/{namespace}/jobs/{name}/status","description":"replace status of the specified Job","kind":"Job","version":"v1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoordinationV1NamespacedLease","level":"stable","category":"coordination","path":"/apis/coordination.k8s.io/v1/namespaces/{namespace}/leases/{name}","description":"replace the specified Lease","kind":"Lease","version":"v1","group":"coordination.k8s.io","action":"put","tested":true,"conf_tested":true,"tests":["[k8s.io] Lease lease API should be available [Conformance]",null]},{"endpoint":"replaceCoreV1Namespace","level":"stable","category":"core","path":"/api/v1/namespaces/{name}","description":"replace the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]"]},{"endpoint":"replaceCoreV1NamespacedConfigMap","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/configmaps/{name}","description":"replace the specified ConfigMap","kind":"ConfigMap","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","[sig-node] ConfigMap should update ConfigMap successfully","[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]",null]},{"endpoint":"replaceCoreV1NamespacedEndpoints","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/endpoints/{name}","description":"replace the specified Endpoints","kind":"Endpoints","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1NamespacedEvent","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/events/{name}","description":"replace the specified Event","kind":"Event","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1NamespacedLimitRange","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/limitranges/{name}","description":"replace the specified LimitRange","kind":"LimitRange","version":"v1","group":"","action":"put","tested":true,"conf_tested":false,"tests":["[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied."]},{"endpoint":"replaceCoreV1NamespacedPersistentVolumeClaim","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}","description":"replace the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"put","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] Mounted volume expand Should verify mounted devices can be resized",null]},{"endpoint":"replaceCoreV1NamespacedPersistentVolumeClaimStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status","description":"replace status of the specified PersistentVolumeClaim","kind":"PersistentVolumeClaim","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1NamespacedPod","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}","description":"replace the specified Pod","kind":"Pod","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","[k8s.io] Pods should be updated [NodeConformance] [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","[sig-apps] ReplicationController should release no longer matching pods [Conformance]","[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]",null]},{"endpoint":"replaceCoreV1NamespacedPodStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/pods/{name}/status","description":"replace status of the specified Pod","kind":"Pod","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1NamespacedPodTemplate","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/podtemplates/{name}","description":"replace the specified PodTemplate","kind":"PodTemplate","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1NamespacedReplicationController","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}","description":"replace the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"replaceCoreV1NamespacedReplicationControllerScale","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale","description":"replace scale of the specified ReplicationController","kind":"Scale","version":"v1","group":"autoscaling","action":"put","tested":true,"conf_tested":false,"tests":["[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"replaceCoreV1NamespacedReplicationControllerStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status","description":"replace status of the specified ReplicationController","kind":"ReplicationController","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1NamespacedResourceQuota","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}","description":"replace the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource."]},{"endpoint":"replaceCoreV1NamespacedResourceQuotaStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/resourcequotas/{name}/status","description":"replace status of the specified ResourceQuota","kind":"ResourceQuota","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1NamespacedSecret","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/secrets/{name}","description":"replace the specified Secret","kind":"Secret","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]",null]},{"endpoint":"replaceCoreV1NamespacedService","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}","description":"replace the specified Service","kind":"Service","version":"v1","group":"","action":"put","tested":true,"conf_tested":true,"tests":["[sig-network] DNS should provide DNS for ExternalName services [Conformance]","[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","[sig-network] Services should check NodePort out-of-range","[sig-network] Services should create endpoints for unready pods","[sig-network] Services should implement service.kubernetes.io/headless","[sig-network] Services should implement service.kubernetes.io/service-proxy-name"]},{"endpoint":"replaceCoreV1NamespacedServiceAccount","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/serviceaccounts/{name}","description":"replace the specified ServiceAccount","kind":"ServiceAccount","version":"v1","group":"","action":"put","tested":true,"conf_tested":false,"tests":["[sig-auth] ServiceAccounts should ensure a single API token exists",null]},{"endpoint":"replaceCoreV1NamespacedServiceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{namespace}/services/{name}/status","description":"replace status of the specified Service","kind":"Service","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1NamespaceFinalize","level":"stable","category":"core","path":"/api/v1/namespaces/{name}/finalize","description":"replace finalize of the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1NamespaceStatus","level":"stable","category":"core","path":"/api/v1/namespaces/{name}/status","description":"replace status of the specified Namespace","kind":"Namespace","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1Node","level":"stable","category":"core","path":"/api/v1/nodes/{name}","description":"replace the specified Node","kind":"Node","version":"v1","group":"","action":"put","tested":true,"conf_tested":false,"tests":["[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s."]},{"endpoint":"replaceCoreV1NodeStatus","level":"stable","category":"core","path":"/api/v1/nodes/{name}/status","description":"replace status of the specified Node","kind":"Node","version":"v1","group":"","action":"put","tested":true,"conf_tested":false,"tests":["[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path"]},{"endpoint":"replaceCoreV1PersistentVolume","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}","description":"replace the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoreV1PersistentVolumeStatus","level":"stable","category":"core","path":"/api/v1/persistentvolumes/{name}/status","description":"replace status of the specified PersistentVolume","kind":"PersistentVolume","version":"v1","group":"","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceNetworkingV1NamespacedNetworkPolicy","level":"stable","category":"networking","path":"/apis/networking.k8s.io/v1/namespaces/{namespace}/networkpolicies/{name}","description":"replace the specified NetworkPolicy","kind":"NetworkPolicy","version":"v1","group":"networking.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1ClusterRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterroles/{name}","description":"replace the specified ClusterRole","kind":"ClusterRole","version":"v1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1ClusterRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/clusterrolebindings/{name}","description":"replace the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1NamespacedRole","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/roles/{name}","description":"replace the specified Role","kind":"Role","version":"v1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1NamespacedRoleBinding","level":"stable","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1/namespaces/{namespace}/rolebindings/{name}","description":"replace the specified RoleBinding","kind":"RoleBinding","version":"v1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceSchedulingV1PriorityClass","level":"stable","category":"scheduling","path":"/apis/scheduling.k8s.io/v1/priorityclasses/{name}","description":"replace the specified PriorityClass","kind":"PriorityClass","version":"v1","group":"scheduling.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceStorageV1CSINode","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/csinodes/{name}","description":"replace the specified CSINode","kind":"CSINode","version":"v1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceStorageV1StorageClass","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/storageclasses/{name}","description":"replace the specified StorageClass","kind":"StorageClass","version":"v1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceStorageV1VolumeAttachment","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}","description":"replace the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceStorageV1VolumeAttachmentStatus","level":"stable","category":"storage","path":"/apis/storage.k8s.io/v1/volumeattachments/{name}/status","description":"replace status of the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations","description":"create a MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations","description":"create a ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions","description":"create a CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices","description":"create an APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1beta1NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions","description":"create a ControllerRevision","kind":"ControllerRevision","version":"v1beta1","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1beta1NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments","description":"create a Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1beta1NamespacedDeploymentRollback","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/rollback","description":"create rollback of a Deployment","kind":"DeploymentRollback","version":"v1beta1","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1beta1NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets","description":"create a StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1beta2NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions","description":"create a ControllerRevision","kind":"ControllerRevision","version":"v1beta2","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1beta2NamespacedDaemonSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/daemonsets","description":"create a DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1beta2NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments","description":"create a Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1beta2NamespacedReplicaSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets","description":"create a ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAppsV1beta2NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets","description":"create a StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAuthenticationV1beta1TokenReview","level":"beta","category":"authentication","path":"/apis/authentication.k8s.io/v1beta1/tokenreviews","description":"create a TokenReview","kind":"TokenReview","version":"v1beta1","group":"authentication.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAuthorizationV1beta1NamespacedLocalSubjectAccessReview","level":"beta","category":"authorization","path":"/apis/authorization.k8s.io/v1beta1/namespaces/{namespace}/localsubjectaccessreviews","description":"create a LocalSubjectAccessReview","kind":"LocalSubjectAccessReview","version":"v1beta1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAuthorizationV1beta1SelfSubjectAccessReview","level":"beta","category":"authorization","path":"/apis/authorization.k8s.io/v1beta1/selfsubjectaccessreviews","description":"create a SelfSubjectAccessReview","kind":"SelfSubjectAccessReview","version":"v1beta1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAuthorizationV1beta1SelfSubjectRulesReview","level":"beta","category":"authorization","path":"/apis/authorization.k8s.io/v1beta1/selfsubjectrulesreviews","description":"create a SelfSubjectRulesReview","kind":"SelfSubjectRulesReview","version":"v1beta1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAuthorizationV1beta1SubjectAccessReview","level":"beta","category":"authorization","path":"/apis/authorization.k8s.io/v1beta1/subjectaccessreviews","description":"create a SubjectAccessReview","kind":"SubjectAccessReview","version":"v1beta1","group":"authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers","description":"create a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers","description":"create a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs","description":"create a CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"post","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently",null]},{"endpoint":"createCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests","description":"create a CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"post","tested":true,"conf_tested":false,"tests":["[sig-auth] Certificates API should support building a client with a CSR",null]},{"endpoint":"createCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases","description":"create a Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices","description":"create an EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events","description":"create an Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createExtensionsV1beta1NamespacedDaemonSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets","description":"create a DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createExtensionsV1beta1NamespacedDeployment","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments","description":"create a Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createExtensionsV1beta1NamespacedDeploymentRollback","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/rollback","description":"create rollback of a Deployment","kind":"DeploymentRollback","version":"v1beta1","group":"extensions","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses","description":"create an Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createExtensionsV1beta1NamespacedNetworkPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies","description":"create a NetworkPolicy","kind":"NetworkPolicy","version":"v1beta1","group":"extensions","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createExtensionsV1beta1NamespacedReplicaSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets","description":"create a ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createExtensionsV1beta1PodSecurityPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/podsecuritypolicies","description":"create a PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"extensions","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses","description":"create an Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses","description":"create a RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"post","tested":true,"conf_tested":false,"tests":["[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]"]},{"endpoint":"createPolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets","description":"create a PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"post","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should update PodDisruptionBudget status"]},{"endpoint":"createPolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies","description":"create a PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"post","tested":true,"conf_tested":false,"tests":["[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2",null]},{"endpoint":"createRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles","description":"create a ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings","description":"create a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles","description":"create a Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings","description":"create a RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses","description":"create a PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers","description":"create a CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"post","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume"]},{"endpoint":"createStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes","description":"create a CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses","description":"create a StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments","description":"create a VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAdmissionregistrationV1beta1CollectionMutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations","description":"delete collection of MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAdmissionregistrationV1beta1CollectionValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations","description":"delete collection of ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}","description":"delete a MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}","description":"delete a ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteApiextensionsV1beta1CollectionCustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions","description":"delete collection of CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}","description":"delete a CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}","description":"delete an APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteApiregistrationV1beta1CollectionAPIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices","description":"delete collection of APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta1CollectionNamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions","description":"delete collection of ControllerRevision","kind":"ControllerRevision","version":"v1beta1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta1CollectionNamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments","description":"delete collection of Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta1CollectionNamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets","description":"delete collection of StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta1NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}","description":"delete a ControllerRevision","kind":"ControllerRevision","version":"v1beta1","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta1NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}","description":"delete a Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta1NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}","description":"delete a StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta2CollectionNamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions","description":"delete collection of ControllerRevision","kind":"ControllerRevision","version":"v1beta2","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta2CollectionNamespacedDaemonSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/daemonsets","description":"delete collection of DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta2CollectionNamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments","description":"delete collection of Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta2CollectionNamespacedReplicaSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets","description":"delete collection of ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta2CollectionNamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets","description":"delete collection of StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta2NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}","description":"delete a ControllerRevision","kind":"ControllerRevision","version":"v1beta2","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta2NamespacedDaemonSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}","description":"delete a DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta2NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}","description":"delete a Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta2NamespacedReplicaSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}","description":"delete a ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAppsV1beta2NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}","description":"delete a StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAutoscalingV2beta1CollectionNamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers","description":"delete collection of HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"delete a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAutoscalingV2beta2CollectionNamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers","description":"delete collection of HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"delete a HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteBatchV1beta1CollectionNamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs","description":"delete collection of CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}","description":"delete a CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently",null]},{"endpoint":"deleteCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}","description":"delete a CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-auth] Certificates API should support building a client with a CSR"]},{"endpoint":"deleteCertificatesV1beta1CollectionCertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests","description":"delete collection of CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoordinationV1beta1CollectionNamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases","description":"delete collection of Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases/{name}","description":"delete a Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteDiscoveryV1beta1CollectionNamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices","description":"delete collection of EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}","description":"delete an EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteEventsV1beta1CollectionNamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events","description":"delete collection of Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}","description":"delete an Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1CollectionNamespacedDaemonSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets","description":"delete collection of DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1CollectionNamespacedDeployment","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments","description":"delete collection of Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1CollectionNamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses","description":"delete collection of Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1CollectionNamespacedNetworkPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies","description":"delete collection of NetworkPolicy","kind":"NetworkPolicy","version":"v1beta1","group":"extensions","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1CollectionNamespacedReplicaSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets","description":"delete collection of ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1CollectionPodSecurityPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/podsecuritypolicies","description":"delete collection of PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"extensions","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1NamespacedDaemonSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}","description":"delete a DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1NamespacedDeployment","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}","description":"delete a Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"delete an Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1NamespacedNetworkPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}","description":"delete a NetworkPolicy","kind":"NetworkPolicy","version":"v1beta1","group":"extensions","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1NamespacedReplicaSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}","description":"delete a ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteExtensionsV1beta1PodSecurityPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/podsecuritypolicies/{name}","description":"delete a PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"extensions","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteNetworkingV1beta1CollectionNamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses","description":"delete collection of Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"delete an Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteNodeV1beta1CollectionRuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses","description":"delete collection of RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses/{name}","description":"delete a RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass"]},{"endpoint":"deletePolicyV1beta1CollectionNamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets","description":"delete collection of PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deletePolicyV1beta1CollectionPodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies","description":"delete collection of PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deletePolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}","description":"delete a PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deletePolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies/{name}","description":"delete a PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}","description":"delete a ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}","description":"delete a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1beta1CollectionClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles","description":"delete collection of ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1beta1CollectionClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings","description":"delete collection of ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1beta1CollectionNamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles","description":"delete collection of Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings","description":"delete collection of RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}","description":"delete a Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}","description":"delete a RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteSchedulingV1beta1CollectionPriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses","description":"delete collection of PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}","description":"delete a PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1beta1CollectionCSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers","description":"delete collection of CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1beta1CollectionCSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes","description":"delete collection of CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1beta1CollectionStorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses","description":"delete collection of StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1beta1CollectionVolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments","description":"delete collection of VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers/{name}","description":"delete a CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"delete","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume"]},{"endpoint":"deleteStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes/{name}","description":"delete a CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses/{name}","description":"delete a StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments/{name}","description":"delete a VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getAdmissionregistrationV1beta1APIResources","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getApiextensionsV1beta1APIResources","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getApiregistrationV1beta1APIResources","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getAppsV1beta1APIResources","level":"beta","category":"apps","path":"/apis/apps/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getAppsV1beta2APIResources","level":"beta","category":"apps","path":"/apis/apps/v1beta2/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getAuthenticationV1beta1APIResources","level":"beta","category":"authentication","path":"/apis/authentication.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getAuthorizationV1beta1APIResources","level":"beta","category":"authorization","path":"/apis/authorization.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getAutoscalingV2beta1APIResources","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getAutoscalingV2beta2APIResources","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getBatchV1beta1APIResources","level":"beta","category":"batch","path":"/apis/batch/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getCertificatesV1beta1APIResources","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getCoordinationV1beta1APIResources","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getDiscoveryV1beta1APIResources","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getEventsV1beta1APIResources","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getExtensionsV1beta1APIResources","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getNetworkingV1beta1APIResources","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getNodeV1beta1APIResources","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getPolicyV1beta1APIResources","level":"beta","category":"policy","path":"/apis/policy/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getRbacAuthorizationV1beta1APIResources","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getSchedulingV1beta1APIResources","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getStorageV1beta1APIResources","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"listAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations","description":"list or watch objects of kind MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations","description":"list or watch objects of kind ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions","description":"list or watch objects of kind CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices","description":"list or watch objects of kind APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta1ControllerRevisionForAllNamespaces","level":"beta","category":"apps","path":"/apis/apps/v1beta1/controllerrevisions","description":"list or watch objects of kind ControllerRevision","kind":"ControllerRevision","version":"v1beta1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta1DeploymentForAllNamespaces","level":"beta","category":"apps","path":"/apis/apps/v1beta1/deployments","description":"list or watch objects of kind Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta1NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions","description":"list or watch objects of kind ControllerRevision","kind":"ControllerRevision","version":"v1beta1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta1NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments","description":"list or watch objects of kind Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta1NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets","description":"list or watch objects of kind StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta1StatefulSetForAllNamespaces","level":"beta","category":"apps","path":"/apis/apps/v1beta1/statefulsets","description":"list or watch objects of kind StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta2ControllerRevisionForAllNamespaces","level":"beta","category":"apps","path":"/apis/apps/v1beta2/controllerrevisions","description":"list or watch objects of kind ControllerRevision","kind":"ControllerRevision","version":"v1beta2","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta2DaemonSetForAllNamespaces","level":"beta","category":"apps","path":"/apis/apps/v1beta2/daemonsets","description":"list or watch objects of kind DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta2DeploymentForAllNamespaces","level":"beta","category":"apps","path":"/apis/apps/v1beta2/deployments","description":"list or watch objects of kind Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta2NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions","description":"list or watch objects of kind ControllerRevision","kind":"ControllerRevision","version":"v1beta2","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta2NamespacedDaemonSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/daemonsets","description":"list or watch objects of kind DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta2NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments","description":"list or watch objects of kind Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta2NamespacedReplicaSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets","description":"list or watch objects of kind ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta2NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets","description":"list or watch objects of kind StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta2ReplicaSetForAllNamespaces","level":"beta","category":"apps","path":"/apis/apps/v1beta2/replicasets","description":"list or watch objects of kind ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAppsV1beta2StatefulSetForAllNamespaces","level":"beta","category":"apps","path":"/apis/apps/v1beta2/statefulsets","description":"list or watch objects of kind StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAutoscalingV2beta1HorizontalPodAutoscalerForAllNamespaces","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAutoscalingV2beta2HorizontalPodAutoscalerForAllNamespaces","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers","description":"list or watch objects of kind HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listBatchV1beta1CronJobForAllNamespaces","level":"beta","category":"batch","path":"/apis/batch/v1beta1/cronjobs","description":"list or watch objects of kind CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs","description":"list or watch objects of kind CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"list","tested":true,"conf_tested":false,"tests":["[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","[sig-cli] Kubectl client Kubectl run CronJob should create a CronJob",null]},{"endpoint":"listCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests","description":"list or watch objects of kind CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoordinationV1beta1LeaseForAllNamespaces","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/leases","description":"list or watch objects of kind Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases","description":"list or watch objects of kind Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listDiscoveryV1beta1EndpointSliceForAllNamespaces","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/endpointslices","description":"list or watch objects of kind EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices","description":"list or watch objects of kind EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listEventsV1beta1EventForAllNamespaces","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/events","description":"list or watch objects of kind Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events","description":"list or watch objects of kind Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1DaemonSetForAllNamespaces","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/daemonsets","description":"list or watch objects of kind DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1DeploymentForAllNamespaces","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/deployments","description":"list or watch objects of kind Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1IngressForAllNamespaces","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/ingresses","description":"list or watch objects of kind Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1NamespacedDaemonSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets","description":"list or watch objects of kind DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1NamespacedDeployment","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments","description":"list or watch objects of kind Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses","description":"list or watch objects of kind Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1NamespacedNetworkPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies","description":"list or watch objects of kind NetworkPolicy","kind":"NetworkPolicy","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1NamespacedReplicaSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets","description":"list or watch objects of kind ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1NetworkPolicyForAllNamespaces","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/networkpolicies","description":"list or watch objects of kind NetworkPolicy","kind":"NetworkPolicy","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1PodSecurityPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/podsecuritypolicies","description":"list or watch objects of kind PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listExtensionsV1beta1ReplicaSetForAllNamespaces","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/replicasets","description":"list or watch objects of kind ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listNetworkingV1beta1IngressForAllNamespaces","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/ingresses","description":"list or watch objects of kind Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses","description":"list or watch objects of kind Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses","description":"list or watch objects of kind RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listPolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets","description":"list or watch objects of kind PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listPolicyV1beta1PodDisruptionBudgetForAllNamespaces","level":"beta","category":"policy","path":"/apis/policy/v1beta1/poddisruptionbudgets","description":"list or watch objects of kind PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listPolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies","description":"list or watch objects of kind PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"list","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]",null]},{"endpoint":"listRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles","description":"list or watch objects of kind ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings","description":"list or watch objects of kind ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1beta1RoleBindingForAllNamespaces","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1beta1RoleForAllNamespaces","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses","description":"list or watch objects of kind PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers","description":"list or watch objects of kind CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes","description":"list or watch objects of kind CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses","description":"list or watch objects of kind StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments","description":"list or watch objects of kind VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}","description":"partially update the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}","description":"partially update the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}","description":"partially update the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchApiextensionsV1beta1CustomResourceDefinitionStatus","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status","description":"partially update status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}","description":"partially update the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchApiregistrationV1beta1APIServiceStatus","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status","description":"partially update status of the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta1NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}","description":"partially update the specified ControllerRevision","kind":"ControllerRevision","version":"v1beta1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta1NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}","description":"partially update the specified Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta1NamespacedDeploymentScale","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale","description":"partially update scale of the specified Deployment","kind":"Scale","version":"v1beta1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta1NamespacedDeploymentStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status","description":"partially update status of the specified Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta1NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}","description":"partially update the specified StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta1NamespacedStatefulSetScale","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale","description":"partially update scale of the specified StatefulSet","kind":"Scale","version":"v1beta1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta1NamespacedStatefulSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status","description":"partially update status of the specified StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}","description":"partially update the specified ControllerRevision","kind":"ControllerRevision","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedDaemonSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}","description":"partially update the specified DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedDaemonSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status","description":"partially update status of the specified DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}","description":"partially update the specified Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedDeploymentScale","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale","description":"partially update scale of the specified Deployment","kind":"Scale","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedDeploymentStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status","description":"partially update status of the specified Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedReplicaSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}","description":"partially update the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedReplicaSetScale","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale","description":"partially update scale of the specified ReplicaSet","kind":"Scale","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedReplicaSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status","description":"partially update status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}","description":"partially update the specified StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedStatefulSetScale","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale","description":"partially update scale of the specified StatefulSet","kind":"Scale","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAppsV1beta2NamespacedStatefulSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status","description":"partially update status of the specified StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"partially update the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"partially update status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"partially update the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"partially update status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}","description":"partially update the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchBatchV1beta1NamespacedCronJobStatus","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status","description":"partially update status of the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}","description":"partially update the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCertificatesV1beta1CertificateSigningRequestStatus","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status","description":"partially update status of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases/{name}","description":"partially update the specified Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}","description":"partially update the specified EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}","description":"partially update the specified Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedDaemonSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}","description":"partially update the specified DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedDaemonSetStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status","description":"partially update status of the specified DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedDeployment","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}","description":"partially update the specified Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedDeploymentScale","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale","description":"partially update scale of the specified Deployment","kind":"Scale","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedDeploymentStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status","description":"partially update status of the specified Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"partially update the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedIngressStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"partially update status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedNetworkPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}","description":"partially update the specified NetworkPolicy","kind":"NetworkPolicy","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedReplicaSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}","description":"partially update the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedReplicaSetScale","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale","description":"partially update scale of the specified ReplicaSet","kind":"Scale","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedReplicaSetStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status","description":"partially update status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1NamespacedReplicationControllerDummyScale","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale","description":"partially update scale of the specified ReplicationControllerDummy","kind":"Scale","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchExtensionsV1beta1PodSecurityPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/podsecuritypolicies/{name}","description":"partially update the specified PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"extensions","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"partially update the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchNetworkingV1beta1NamespacedIngressStatus","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"partially update status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses/{name}","description":"partially update the specified RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchPolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}","description":"partially update the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchPolicyV1beta1NamespacedPodDisruptionBudgetStatus","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status","description":"partially update status of the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchPolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies/{name}","description":"partially update the specified PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}","description":"partially update the specified ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}","description":"partially update the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}","description":"partially update the specified Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}","description":"partially update the specified RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}","description":"partially update the specified PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers/{name}","description":"partially update the specified CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes/{name}","description":"partially update the specified CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses/{name}","description":"partially update the specified StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments/{name}","description":"partially update the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}","description":"read the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}","description":"read the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}","description":"read the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"get","tested":true,"conf_tested":true,"tests":["[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","[sig-api-machinery] Discovery Custom resource should have storage version hash","[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema",null]},{"endpoint":"readApiextensionsV1beta1CustomResourceDefinitionStatus","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status","description":"read status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}","description":"read the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readApiregistrationV1beta1APIServiceStatus","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status","description":"read status of the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta1NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}","description":"read the specified ControllerRevision","kind":"ControllerRevision","version":"v1beta1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta1NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}","description":"read the specified Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta1NamespacedDeploymentScale","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale","description":"read scale of the specified Deployment","kind":"Scale","version":"v1beta1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta1NamespacedDeploymentStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status","description":"read status of the specified Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta1NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}","description":"read the specified StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta1NamespacedStatefulSetScale","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale","description":"read scale of the specified StatefulSet","kind":"Scale","version":"v1beta1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta1NamespacedStatefulSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status","description":"read status of the specified StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}","description":"read the specified ControllerRevision","kind":"ControllerRevision","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedDaemonSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}","description":"read the specified DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedDaemonSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status","description":"read status of the specified DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}","description":"read the specified Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedDeploymentScale","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale","description":"read scale of the specified Deployment","kind":"Scale","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedDeploymentStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status","description":"read status of the specified Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedReplicaSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}","description":"read the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedReplicaSetScale","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale","description":"read scale of the specified ReplicaSet","kind":"Scale","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedReplicaSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status","description":"read status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}","description":"read the specified StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedStatefulSetScale","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale","description":"read scale of the specified StatefulSet","kind":"Scale","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAppsV1beta2NamespacedStatefulSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status","description":"read status of the specified StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"read the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"read status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"read the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"read status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}","description":"read the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"get","tested":true,"conf_tested":false,"tests":["[sig-apps] CronJob should not emit unexpected warnings","[sig-apps] CronJob should remove from active list jobs that have been deleted","[sig-apps] CronJob should replace jobs when ReplaceConcurrent","[sig-apps] CronJob should schedule multiple jobs concurrently","[sig-cli] Kubectl alpha client Kubectl run CronJob should create a CronJob","[sig-cli] Kubectl client Kubectl run CronJob should create a CronJob",null]},{"endpoint":"readBatchV1beta1NamespacedCronJobStatus","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status","description":"read status of the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}","description":"read the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"get","tested":true,"conf_tested":false,"tests":["[sig-auth] Certificates API should support building a client with a CSR"]},{"endpoint":"readCertificatesV1beta1CertificateSigningRequestStatus","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status","description":"read status of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases/{name}","description":"read the specified Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}","description":"read the specified EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}","description":"read the specified Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedDaemonSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}","description":"read the specified DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedDaemonSetStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status","description":"read status of the specified DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedDeployment","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}","description":"read the specified Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedDeploymentScale","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale","description":"read scale of the specified Deployment","kind":"Scale","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedDeploymentStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status","description":"read status of the specified Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"read the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedIngressStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"read status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedNetworkPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}","description":"read the specified NetworkPolicy","kind":"NetworkPolicy","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedReplicaSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}","description":"read the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedReplicaSetScale","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale","description":"read scale of the specified ReplicaSet","kind":"Scale","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedReplicaSetStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status","description":"read status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1NamespacedReplicationControllerDummyScale","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale","description":"read scale of the specified ReplicationControllerDummy","kind":"Scale","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readExtensionsV1beta1PodSecurityPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/podsecuritypolicies/{name}","description":"read the specified PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"extensions","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"read the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readNetworkingV1beta1NamespacedIngressStatus","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"read status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses/{name}","description":"read the specified RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"get","tested":true,"conf_tested":false,"tests":["[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass"]},{"endpoint":"readPolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}","description":"read the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"get","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","[sig-apps] DisruptionController should create a PodDisruptionBudget","[sig-apps] DisruptionController should update PodDisruptionBudget status"]},{"endpoint":"readPolicyV1beta1NamespacedPodDisruptionBudgetStatus","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status","description":"read status of the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readPolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies/{name}","description":"read the specified PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"get","tested":true,"conf_tested":true,"tests":["[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","[sig-network] Networking Granular Checks: Services should function for node-Service: http","[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]",null]},{"endpoint":"readRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}","description":"read the specified ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}","description":"read the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}","description":"read the specified Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}","description":"read the specified RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}","description":"read the specified PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers/{name}","description":"read the specified CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"get","tested":true,"conf_tested":false,"tests":["[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil"]},{"endpoint":"readStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes/{name}","description":"read the specified CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses/{name}","description":"read the specified StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments/{name}","description":"read the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAdmissionregistrationV1beta1MutatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/mutatingwebhookconfigurations/{name}","description":"replace the specified MutatingWebhookConfiguration","kind":"MutatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAdmissionregistrationV1beta1ValidatingWebhookConfiguration","level":"beta","category":"admissionregistration","path":"/apis/admissionregistration.k8s.io/v1beta1/validatingwebhookconfigurations/{name}","description":"replace the specified ValidatingWebhookConfiguration","kind":"ValidatingWebhookConfiguration","version":"v1beta1","group":"admissionregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceApiextensionsV1beta1CustomResourceDefinition","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}","description":"replace the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceApiextensionsV1beta1CustomResourceDefinitionStatus","level":"beta","category":"apiextensions","path":"/apis/apiextensions.k8s.io/v1beta1/customresourcedefinitions/{name}/status","description":"replace status of the specified CustomResourceDefinition","kind":"CustomResourceDefinition","version":"v1beta1","group":"apiextensions.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceApiregistrationV1beta1APIService","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}","description":"replace the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceApiregistrationV1beta1APIServiceStatus","level":"beta","category":"apiregistration","path":"/apis/apiregistration.k8s.io/v1beta1/apiservices/{name}/status","description":"replace status of the specified APIService","kind":"APIService","version":"v1beta1","group":"apiregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta1NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/controllerrevisions/{name}","description":"replace the specified ControllerRevision","kind":"ControllerRevision","version":"v1beta1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta1NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}","description":"replace the specified Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta1NamespacedDeploymentScale","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/scale","description":"replace scale of the specified Deployment","kind":"Scale","version":"v1beta1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta1NamespacedDeploymentStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/deployments/{name}/status","description":"replace status of the specified Deployment","kind":"Deployment","version":"v1beta1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta1NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}","description":"replace the specified StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta1NamespacedStatefulSetScale","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/scale","description":"replace scale of the specified StatefulSet","kind":"Scale","version":"v1beta1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta1NamespacedStatefulSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta1/namespaces/{namespace}/statefulsets/{name}/status","description":"replace status of the specified StatefulSet","kind":"StatefulSet","version":"v1beta1","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedControllerRevision","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/controllerrevisions/{name}","description":"replace the specified ControllerRevision","kind":"ControllerRevision","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedDaemonSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}","description":"replace the specified DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedDaemonSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/daemonsets/{name}/status","description":"replace status of the specified DaemonSet","kind":"DaemonSet","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedDeployment","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}","description":"replace the specified Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedDeploymentScale","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/scale","description":"replace scale of the specified Deployment","kind":"Scale","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedDeploymentStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/deployments/{name}/status","description":"replace status of the specified Deployment","kind":"Deployment","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedReplicaSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}","description":"replace the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedReplicaSetScale","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/scale","description":"replace scale of the specified ReplicaSet","kind":"Scale","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedReplicaSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/replicasets/{name}/status","description":"replace status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedStatefulSet","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}","description":"replace the specified StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedStatefulSetScale","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/scale","description":"replace scale of the specified StatefulSet","kind":"Scale","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAppsV1beta2NamespacedStatefulSetStatus","level":"beta","category":"apps","path":"/apis/apps/v1beta2/namespaces/{namespace}/statefulsets/{name}/status","description":"replace status of the specified StatefulSet","kind":"StatefulSet","version":"v1beta2","group":"apps","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAutoscalingV2beta1NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"replace the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAutoscalingV2beta1NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta1/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"replace status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta1","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAutoscalingV2beta2NamespacedHorizontalPodAutoscaler","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}","description":"replace the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAutoscalingV2beta2NamespacedHorizontalPodAutoscalerStatus","level":"beta","category":"autoscaling","path":"/apis/autoscaling/v2beta2/namespaces/{namespace}/horizontalpodautoscalers/{name}/status","description":"replace status of the specified HorizontalPodAutoscaler","kind":"HorizontalPodAutoscaler","version":"v2beta2","group":"autoscaling","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceBatchV1beta1NamespacedCronJob","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}","description":"replace the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceBatchV1beta1NamespacedCronJobStatus","level":"beta","category":"batch","path":"/apis/batch/v1beta1/namespaces/{namespace}/cronjobs/{name}/status","description":"replace status of the specified CronJob","kind":"CronJob","version":"v1beta1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCertificatesV1beta1CertificateSigningRequest","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}","description":"replace the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCertificatesV1beta1CertificateSigningRequestApproval","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/approval","description":"replace approval of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"put","tested":true,"conf_tested":false,"tests":["[sig-auth] Certificates API should support building a client with a CSR",null]},{"endpoint":"replaceCertificatesV1beta1CertificateSigningRequestStatus","level":"beta","category":"certificates","path":"/apis/certificates.k8s.io/v1beta1/certificatesigningrequests/{name}/status","description":"replace status of the specified CertificateSigningRequest","kind":"CertificateSigningRequest","version":"v1beta1","group":"certificates.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceCoordinationV1beta1NamespacedLease","level":"beta","category":"coordination","path":"/apis/coordination.k8s.io/v1beta1/namespaces/{namespace}/leases/{name}","description":"replace the specified Lease","kind":"Lease","version":"v1beta1","group":"coordination.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceDiscoveryV1beta1NamespacedEndpointSlice","level":"beta","category":"discovery","path":"/apis/discovery.k8s.io/v1beta1/namespaces/{namespace}/endpointslices/{name}","description":"replace the specified EndpointSlice","kind":"EndpointSlice","version":"v1beta1","group":"discovery.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceEventsV1beta1NamespacedEvent","level":"beta","category":"events","path":"/apis/events.k8s.io/v1beta1/namespaces/{namespace}/events/{name}","description":"replace the specified Event","kind":"Event","version":"v1beta1","group":"events.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedDaemonSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}","description":"replace the specified DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedDaemonSetStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/daemonsets/{name}/status","description":"replace status of the specified DaemonSet","kind":"DaemonSet","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedDeployment","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}","description":"replace the specified Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedDeploymentScale","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/scale","description":"replace scale of the specified Deployment","kind":"Scale","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedDeploymentStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/deployments/{name}/status","description":"replace status of the specified Deployment","kind":"Deployment","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedIngress","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"replace the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedIngressStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"replace status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedNetworkPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/networkpolicies/{name}","description":"replace the specified NetworkPolicy","kind":"NetworkPolicy","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedReplicaSet","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}","description":"replace the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedReplicaSetScale","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/scale","description":"replace scale of the specified ReplicaSet","kind":"Scale","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedReplicaSetStatus","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicasets/{name}/status","description":"replace status of the specified ReplicaSet","kind":"ReplicaSet","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1NamespacedReplicationControllerDummyScale","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/namespaces/{namespace}/replicationcontrollers/{name}/scale","description":"replace scale of the specified ReplicationControllerDummy","kind":"Scale","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceExtensionsV1beta1PodSecurityPolicy","level":"beta","category":"extensions","path":"/apis/extensions/v1beta1/podsecuritypolicies/{name}","description":"replace the specified PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"extensions","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceNetworkingV1beta1NamespacedIngress","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}","description":"replace the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceNetworkingV1beta1NamespacedIngressStatus","level":"beta","category":"networking","path":"/apis/networking.k8s.io/v1beta1/namespaces/{namespace}/ingresses/{name}/status","description":"replace status of the specified Ingress","kind":"Ingress","version":"v1beta1","group":"networking.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceNodeV1beta1RuntimeClass","level":"beta","category":"node","path":"/apis/node.k8s.io/v1beta1/runtimeclasses/{name}","description":"replace the specified RuntimeClass","kind":"RuntimeClass","version":"v1beta1","group":"node.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replacePolicyV1beta1NamespacedPodDisruptionBudget","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}","description":"replace the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"put","tested":true,"conf_tested":false,"tests":["[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it"]},{"endpoint":"replacePolicyV1beta1NamespacedPodDisruptionBudgetStatus","level":"beta","category":"policy","path":"/apis/policy/v1beta1/namespaces/{namespace}/poddisruptionbudgets/{name}/status","description":"replace status of the specified PodDisruptionBudget","kind":"PodDisruptionBudget","version":"v1beta1","group":"policy","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replacePolicyV1beta1PodSecurityPolicy","level":"beta","category":"policy","path":"/apis/policy/v1beta1/podsecuritypolicies/{name}","description":"replace the specified PodSecurityPolicy","kind":"PodSecurityPolicy","version":"v1beta1","group":"policy","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1beta1ClusterRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterroles/{name}","description":"replace the specified ClusterRole","kind":"ClusterRole","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1beta1ClusterRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindings/{name}","description":"replace the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1beta1NamespacedRole","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/roles/{name}","description":"replace the specified Role","kind":"Role","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1beta1NamespacedRoleBinding","level":"beta","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1beta1/namespaces/{namespace}/rolebindings/{name}","description":"replace the specified RoleBinding","kind":"RoleBinding","version":"v1beta1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceSchedulingV1beta1PriorityClass","level":"beta","category":"scheduling","path":"/apis/scheduling.k8s.io/v1beta1/priorityclasses/{name}","description":"replace the specified PriorityClass","kind":"PriorityClass","version":"v1beta1","group":"scheduling.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceStorageV1beta1CSIDriver","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csidrivers/{name}","description":"replace the specified CSIDriver","kind":"CSIDriver","version":"v1beta1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceStorageV1beta1CSINode","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/csinodes/{name}","description":"replace the specified CSINode","kind":"CSINode","version":"v1beta1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceStorageV1beta1StorageClass","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/storageclasses/{name}","description":"replace the specified StorageClass","kind":"StorageClass","version":"v1beta1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceStorageV1beta1VolumeAttachment","level":"beta","category":"storage","path":"/apis/storage.k8s.io/v1beta1/volumeattachments/{name}","description":"replace the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1beta1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createAuditregistrationV1alpha1AuditSink","level":"alpha","category":"auditregistration","path":"/apis/auditregistration.k8s.io/v1alpha1/auditsinks","description":"create an AuditSink","kind":"AuditSink","version":"v1alpha1","group":"auditregistration.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs","description":"create a CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas","description":"create a FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations","description":"create a PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses","description":"create a RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles","description":"create a ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings","description":"create a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles","description":"create a Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings","description":"create a RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses","description":"create a PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets","description":"create a PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"createStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments","description":"create a VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"post","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAuditregistrationV1alpha1AuditSink","level":"alpha","category":"auditregistration","path":"/apis/auditregistration.k8s.io/v1alpha1/auditsinks/{name}","description":"delete an AuditSink","kind":"AuditSink","version":"v1alpha1","group":"auditregistration.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteAuditregistrationV1alpha1CollectionAuditSink","level":"alpha","category":"auditregistration","path":"/apis/auditregistration.k8s.io/v1alpha1/auditsinks","description":"delete collection of AuditSink","kind":"AuditSink","version":"v1alpha1","group":"auditregistration.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteBatchV2alpha1CollectionNamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs","description":"delete collection of CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}","description":"delete a CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteFlowcontrolApiserverV1alpha1CollectionFlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas","description":"delete collection of FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteFlowcontrolApiserverV1alpha1CollectionPriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations","description":"delete collection of PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}","description":"delete a FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}","description":"delete a PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteNodeV1alpha1CollectionRuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses","description":"delete collection of RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses/{name}","description":"delete a RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}","description":"delete a ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}","description":"delete a ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1alpha1CollectionClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles","description":"delete collection of ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1alpha1CollectionClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings","description":"delete collection of ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1alpha1CollectionNamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles","description":"delete collection of Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1alpha1CollectionNamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings","description":"delete collection of RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}","description":"delete a Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}","description":"delete a RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteSchedulingV1alpha1CollectionPriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses","description":"delete collection of PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}","description":"delete a PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteSettingsV1alpha1CollectionNamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets","description":"delete collection of PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}","description":"delete a PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1alpha1CollectionVolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments","description":"delete collection of VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"deletecollection","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"deleteStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}","description":"delete a VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"delete","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getAuditregistrationV1alpha1APIResources","level":"alpha","category":"auditregistration","path":"/apis/auditregistration.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getBatchV2alpha1APIResources","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getFlowcontrolApiserverV1alpha1APIResources","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getNodeV1alpha1APIResources","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getRbacAuthorizationV1alpha1APIResources","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"getSchedulingV1alpha1APIResources","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getSettingsV1alpha1APIResources","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":true,"conf_tested":true,"tests":["[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","[sig-network] Services should create endpoints for unready pods",null]},{"endpoint":"getStorageV1alpha1APIResources","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/","description":"get available resources","kind":null,"version":null,"group":null,"action":null,"tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listAuditregistrationV1alpha1AuditSink","level":"alpha","category":"auditregistration","path":"/apis/auditregistration.k8s.io/v1alpha1/auditsinks","description":"list or watch objects of kind AuditSink","kind":"AuditSink","version":"v1alpha1","group":"auditregistration.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listBatchV2alpha1CronJobForAllNamespaces","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/cronjobs","description":"list or watch objects of kind CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs","description":"list or watch objects of kind CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"list","tested":true,"conf_tested":false,"tests":["[sig-cli] Kubectl alpha client Kubectl run CronJob should create a CronJob"]},{"endpoint":"listFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas","description":"list or watch objects of kind FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations","description":"list or watch objects of kind PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses","description":"list or watch objects of kind RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles","description":"list or watch objects of kind ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings","description":"list or watch objects of kind ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1alpha1RoleBindingForAllNamespaces","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/rolebindings","description":"list or watch objects of kind RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listRbacAuthorizationV1alpha1RoleForAllNamespaces","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/roles","description":"list or watch objects of kind Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses","description":"list or watch objects of kind PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets","description":"list or watch objects of kind PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listSettingsV1alpha1PodPresetForAllNamespaces","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/podpresets","description":"list or watch objects of kind PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"listStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments","description":"list or watch objects of kind VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"list","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchAuditregistrationV1alpha1AuditSink","level":"alpha","category":"auditregistration","path":"/apis/auditregistration.k8s.io/v1alpha1/auditsinks/{name}","description":"partially update the specified AuditSink","kind":"AuditSink","version":"v1alpha1","group":"auditregistration.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}","description":"partially update the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchBatchV2alpha1NamespacedCronJobStatus","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status","description":"partially update status of the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}","description":"partially update the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchFlowcontrolApiserverV1alpha1FlowSchemaStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}/status","description":"partially update status of the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}","description":"partially update the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}/status","description":"partially update status of the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses/{name}","description":"partially update the specified RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}","description":"partially update the specified ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}","description":"partially update the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}","description":"partially update the specified Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}","description":"partially update the specified RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}","description":"partially update the specified PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}","description":"partially update the specified PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"patchStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}","description":"partially update the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"patch","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readAuditregistrationV1alpha1AuditSink","level":"alpha","category":"auditregistration","path":"/apis/auditregistration.k8s.io/v1alpha1/auditsinks/{name}","description":"read the specified AuditSink","kind":"AuditSink","version":"v1alpha1","group":"auditregistration.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}","description":"read the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readBatchV2alpha1NamespacedCronJobStatus","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status","description":"read status of the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}","description":"read the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readFlowcontrolApiserverV1alpha1FlowSchemaStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}/status","description":"read status of the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}","description":"read the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}/status","description":"read status of the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses/{name}","description":"read the specified RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}","description":"read the specified ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}","description":"read the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}","description":"read the specified Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}","description":"read the specified RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}","description":"read the specified PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}","description":"read the specified PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"readStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}","description":"read the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"get","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceAuditregistrationV1alpha1AuditSink","level":"alpha","category":"auditregistration","path":"/apis/auditregistration.k8s.io/v1alpha1/auditsinks/{name}","description":"replace the specified AuditSink","kind":"AuditSink","version":"v1alpha1","group":"auditregistration.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceBatchV2alpha1NamespacedCronJob","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}","description":"replace the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceBatchV2alpha1NamespacedCronJobStatus","level":"alpha","category":"batch","path":"/apis/batch/v2alpha1/namespaces/{namespace}/cronjobs/{name}/status","description":"replace status of the specified CronJob","kind":"CronJob","version":"v2alpha1","group":"batch","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceFlowcontrolApiserverV1alpha1FlowSchema","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}","description":"replace the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceFlowcontrolApiserverV1alpha1FlowSchemaStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/flowschemas/{name}/status","description":"replace status of the specified FlowSchema","kind":"FlowSchema","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceFlowcontrolApiserverV1alpha1PriorityLevelConfiguration","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}","description":"replace the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceFlowcontrolApiserverV1alpha1PriorityLevelConfigurationStatus","level":"alpha","category":"flowcontrolApiserver","path":"/apis/flowcontrol.apiserver.k8s.io/v1alpha1/prioritylevelconfigurations/{name}/status","description":"replace status of the specified PriorityLevelConfiguration","kind":"PriorityLevelConfiguration","version":"v1alpha1","group":"flowcontrol.apiserver.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceNodeV1alpha1RuntimeClass","level":"alpha","category":"node","path":"/apis/node.k8s.io/v1alpha1/runtimeclasses/{name}","description":"replace the specified RuntimeClass","kind":"RuntimeClass","version":"v1alpha1","group":"node.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1alpha1ClusterRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/{name}","description":"replace the specified ClusterRole","kind":"ClusterRole","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1alpha1ClusterRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/{name}","description":"replace the specified ClusterRoleBinding","kind":"ClusterRoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1alpha1NamespacedRole","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/roles/{name}","description":"replace the specified Role","kind":"Role","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceRbacAuthorizationV1alpha1NamespacedRoleBinding","level":"alpha","category":"rbacAuthorization","path":"/apis/rbac.authorization.k8s.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}","description":"replace the specified RoleBinding","kind":"RoleBinding","version":"v1alpha1","group":"rbac.authorization.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceSchedulingV1alpha1PriorityClass","level":"alpha","category":"scheduling","path":"/apis/scheduling.k8s.io/v1alpha1/priorityclasses/{name}","description":"replace the specified PriorityClass","kind":"PriorityClass","version":"v1alpha1","group":"scheduling.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceSettingsV1alpha1NamespacedPodPreset","level":"alpha","category":"settings","path":"/apis/settings.k8s.io/v1alpha1/namespaces/{namespace}/podpresets/{name}","description":"replace the specified PodPreset","kind":"PodPreset","version":"v1alpha1","group":"settings.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]},{"endpoint":"replaceStorageV1alpha1VolumeAttachment","level":"alpha","category":"storage","path":"/apis/storage.k8s.io/v1alpha1/volumeattachments/{name}","description":"replace the specified VolumeAttachment","kind":"VolumeAttachment","version":"v1alpha1","group":"storage.k8s.io","action":"put","tested":false,"conf_tested":false,"tests":[null]}],"tests":[{"test":"","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart exec hook properly [NodeConformance] [Conformance]","testname":"Pod Lifecycle, post start exec hook","file":"test/e2e/common/lifecycle_hook.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute poststart http hook properly [NodeConformance] [Conformance]","testname":"Pod Lifecycle, post start http hook","file":"test/e2e/common/lifecycle_hook.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop exec hook properly [NodeConformance] [Conformance]","testname":"Pod Lifecycle, prestop exec hook","file":"test/e2e/common/lifecycle_hook.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Container Lifecycle Hook when create a pod with lifecycle hook should execute prestop http hook properly [NodeConformance] [Conformance]","testname":"Pod Lifecycle, prestop http hook","file":"test/e2e/common/lifecycle_hook.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] as empty when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","testname":"Container Runtime, TerminationMessage, from log output of succeeding container","file":"test/e2e/common/runtime.go","release":"1.15.0","conformance_test":true},{"test":"[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from file when pod succeeds and TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","testname":"Container Runtime, TerminationMessage, from file of succeeding container","file":"test/e2e/common/runtime.go","release":"1.15.0","conformance_test":true},{"test":"[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] from log output if TerminationMessagePolicy FallbackToLogsOnError is set [NodeConformance] [Conformance]","testname":"Container Runtime, TerminationMessage, from container's log output of failing container","file":"test/e2e/common/runtime.go","release":"1.15.0","conformance_test":true},{"test":"[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set as non-root user and at a non-default path [NodeConformance] [Conformance]","testname":"Container Runtime, TerminationMessagePath, non-root user and non-default path","file":"test/e2e/common/runtime.go","release":"1.15.0","conformance_test":true},{"test":"[k8s.io] Container Runtime blackbox test on terminated container should report termination message [LinuxOnly] if TerminationMessagePath is set [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull from private registry with secret [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image from docker hub [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image from docker hub [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image from gcr.io [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image from gcr.io [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should be able to pull image [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull from private registry without secret [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull image from invalid registry [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when running a container with a new image should not be able to pull non-existing image from gcr.io [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Container Runtime blackbox test when starting a container that exits should run with the expected status [NodeConformance] [Conformance]","testname":"Container Runtime, Restart Policy, Pod Phases","file":"test/e2e/common/runtime.go","release":"1.13.0","conformance_test":true},{"test":"[k8s.io] Docker Containers should be able to override the image's default arguments (docker cmd) [NodeConformance] [Conformance]","testname":"Docker containers, with arguments","file":"test/e2e/common/docker_containers.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Docker Containers should be able to override the image's default command and arguments [NodeConformance] [Conformance]","testname":"Docker containers, with command and arguments","file":"test/e2e/common/docker_containers.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Docker Containers should be able to override the image's default command (docker entrypoint) [NodeConformance] [Conformance]","testname":"Docker containers, with command","file":"test/e2e/common/docker_containers.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Docker Containers should use the image defaults if command and args are blank [NodeConformance] [Conformance]","testname":"Docker containers, without command and arguments","file":"test/e2e/common/docker_containers.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartAlways pod [Conformance]","testname":"init-container-starts-app-restartalways-pod","file":"test/e2e/common/init_container.go","release":"1.12.0","conformance_test":true},{"test":"[k8s.io] InitContainer [NodeConformance] should invoke init containers on a RestartNever pod [Conformance]","testname":"init-container-starts-app-restartnever-pod","file":"test/e2e/common/init_container.go","release":"1.12.0","conformance_test":true},{"test":"[k8s.io] InitContainer [NodeConformance] should not start app containers and fail the pod if init containers fail on a RestartNever pod [Conformance]","testname":"init-container-fails-stops-app-restartnever-pod","file":"test/e2e/common/init_container.go","release":"1.12.0","conformance_test":true},{"test":"[k8s.io] InitContainer [NodeConformance] should not start app containers if init containers fail on a RestartAlways pod [Conformance]","testname":"init-container-fails-stops-app-restartalways-pod","file":"test/e2e/common/init_container.go","release":"1.12.0","conformance_test":true},{"test":"[k8s.io] KubeletManagedEtcHosts should test kubelet managed /etc/hosts file [LinuxOnly] [NodeConformance] [Conformance]","testname":"Kubelet, managed etc hosts","file":"test/e2e/common/kubelet_etc_hosts.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Kubelet when scheduling a busybox command in a pod should print the output to logs [NodeConformance] [Conformance]","testname":"Kubelet, log output, default","file":"test/e2e/common/kubelet.go","release":"1.13.0","conformance_test":true},{"test":"[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should be possible to delete [NodeConformance] [Conformance]","testname":"Kubelet, failed pod, delete","file":"test/e2e/common/kubelet.go","release":"1.13.0","conformance_test":true},{"test":"[k8s.io] Kubelet when scheduling a busybox command that always fails in a pod should have an terminated reason [NodeConformance] [Conformance]","testname":"Kubelet, failed pod, terminated reason","file":"test/e2e/common/kubelet.go","release":"1.13.0","conformance_test":true},{"test":"[k8s.io] Kubelet when scheduling a busybox Pod with hostAliases should write entries to /etc/hosts [LinuxOnly] [NodeConformance] [Conformance]","testname":"Kubelet, hostAliases","file":"test/e2e/common/kubelet.go","release":"1.13.0","conformance_test":true},{"test":"[k8s.io] Kubelet when scheduling a read only busybox container should not write to root filesystem [LinuxOnly] [NodeConformance] [Conformance]","testname":"Kubelet, pod with read only root file system","file":"test/e2e/common/kubelet.go","release":"1.13.0","conformance_test":true},{"test":"[k8s.io] Lease API should be available","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Lease lease API should be available [Conformance]","testname":"lease API should be available","file":"test/e2e/common/lease.go","release":"1.17.0","conformance_test":true},{"test":"[k8s.io] NodeLease when the NodeLease feature is enabled should have OwnerReferences set","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should create and update a lease in the kube-node-lease namespace","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] NodeLease when the NodeLease feature is enabled the kubelet should report node status infrequently","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Pods should allow activeDeadlineSeconds to be updated [NodeConformance] [Conformance]","testname":"Pods, ActiveDeadlineSeconds","file":"test/e2e/common/pods.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Pods should be submitted and removed [NodeConformance] [Conformance]","testname":"Pods, lifecycle","file":"test/e2e/common/pods.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Pods should be updated [NodeConformance] [Conformance]","testname":"Pods, update","file":"test/e2e/common/pods.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Pods should contain environment variables for services [NodeConformance] [Conformance]","testname":"Pods, service environment variables","file":"test/e2e/common/pods.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Pods should get a host IP [NodeConformance] [Conformance]","testname":"Pods, assigned hostip","file":"test/e2e/common/pods.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Pods should support pod readiness gates [NodeFeature:PodReadinessGate]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Pods should support remote command execution over websockets [NodeConformance] [Conformance]","testname":"Pods, remote command execution over websocket","file":"test/e2e/common/pods.go","release":"1.13.0","conformance_test":true},{"test":"[k8s.io] Pods should support retrieving logs from the container over websockets [NodeConformance] [Conformance]","testname":"Pods, logs from websockets","file":"test/e2e/common/pods.go","release":"1.13.0","conformance_test":true},{"test":"[k8s.io] PrivilegedPod [NodeConformance] should enable privileged commands [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Probing container should be restarted with a docker exec liveness probe with timeout","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Probing container should be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","testname":"Pod liveness probe, using local file, restart","file":"test/e2e/common/container_probe.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Probing container should be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","testname":"Pod liveness probe, using http endpoint, restart","file":"test/e2e/common/container_probe.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Probing container should be restarted with a local redirect http liveness probe","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Probing container should have monotonically increasing restart count [NodeConformance] [Conformance]","testname":"Pod liveness probe, using http endpoint, multiple restarts (slow)","file":"test/e2e/common/container_probe.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Probing container should *not* be restarted with a exec \"cat /tmp/health\" liveness probe [NodeConformance] [Conformance]","testname":"Pod liveness probe, using local file, no restart","file":"test/e2e/common/container_probe.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Probing container should *not* be restarted with a /healthz http liveness probe [NodeConformance] [Conformance]","testname":"Pod liveness probe, using http endpoint, failure","file":"test/e2e/common/container_probe.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Probing container should *not* be restarted with a non-local redirect http liveness probe","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Probing container should *not* be restarted with a tcp:8080 liveness probe [NodeConformance] [Conformance]","testname":"Pod liveness probe, using tcp socket, no restart","file":"test/e2e/common/container_probe.go","release":"1.18.0","conformance_test":true},{"test":"[k8s.io] Probing container with readiness probe should not be ready before initial delay and never restart [NodeConformance] [Conformance]","testname":"Pod readiness probe, with initial delay","file":"test/e2e/common/container_probe.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Probing container with readiness probe that fails should never be ready and never restart [NodeConformance] [Conformance]","testname":"Pod readiness probe, failure","file":"test/e2e/common/container_probe.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a container with runAsNonRoot should not run with an explicit root user ID [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a container with runAsNonRoot should not run without a specified user ID","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a container with runAsNonRoot should run with an explicit non-root user ID [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a container with runAsNonRoot should run with an image specified user ID","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 0 [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a container with runAsUser should run the container with uid 65534 [LinuxOnly] [NodeConformance] [Conformance]","testname":"Security Context, runAsUser=65534","file":"test/e2e/common/security_context.go","release":"1.15.0","conformance_test":true},{"test":"[k8s.io] Security Context When creating a pod with privileged should run the container as privileged when true [LinuxOnly] [NodeFeature:HostAccess]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a pod with privileged should run the container as unprivileged when false [LinuxOnly] [NodeConformance] [Conformance]","testname":"Security Context, privileged=false.","file":"test/e2e/common/security_context.go","release":"1.15.0","conformance_test":true},{"test":"[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with readonly rootfs when readOnlyRootFilesystem=true [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context When creating a pod with readOnlyRootFilesystem should run the container with writable rootfs when readOnlyRootFilesystem=false [NodeConformance] [Conformance]","testname":"Security Context, readOnlyRootFilesystem=false.","file":"test/e2e/common/security_context.go","release":"1.15.0","conformance_test":true},{"test":"[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when not explicitly set and uid != 0 [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should allow privilege escalation when true [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Security Context when creating containers with AllowPrivilegeEscalation should not allow privilege escalation when false [LinuxOnly] [NodeConformance] [Conformance]","testname":"Security Context, allowPrivilegeEscalation=false.","file":"test/e2e/common/security_context.go","release":"1.15.0","conformance_test":true},{"test":"[k8s.io] [sig-node] AppArmor load AppArmor profiles can disable an AppArmor profile, using unconfined","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] AppArmor load AppArmor profiles should enforce an AppArmor profile","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] crictl should be able to run crictl on the node","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] Events should be sent by kubelets and the scheduler about pods scheduling and running  [Conformance]","testname":"Pod events, verify event from Scheduler and Kubelet","file":"test/e2e/node/events.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] [sig-node] kubelet [k8s.io] [sig-node] Clean up pods on node kubelet should be able to delete 10 pods per node in 1m0s.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] Mount propagation should propagate mounts to the host","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] NodeProblemDetector [DisabledForLargeClusters] should run without error","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] Pods Extended [k8s.io] Delete Grace Period should be submitted and removed [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] Pods Extended [k8s.io] Pod Container Status should never report success for a pending container","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be set on Pods with matching resource requests and limits for memory and cpu [Conformance]","testname":"Pods, QOS","file":"test/e2e/node/pods.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] [sig-node] Pods Extended [k8s.io] Pods Set QOS Class should be submitted and removed  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] PreStop graceful pod terminated should wait until preStop hook completes the process","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] PreStop should call prestop when killing a pod  [Conformance]","testname":"Pods, prestop hook","file":"test/e2e/node/pre_stop.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser And container.SecurityContext.RunAsGroup [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] Security Context should support container.SecurityContext.RunAsUser [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser And pod.Spec.SecurityContext.RunAsGroup [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.RunAsUser [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] Security Context should support pod.Spec.SecurityContext.SupplementalGroups [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] [sig-node] SSH should SSH to all nodes and run commands","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should reject invalid sysctls","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support sysctls","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Sysctls [LinuxOnly] [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Sysctls [NodeFeature:Sysctls] should not launch unsafe, but not explicitly enabled sysctls on the node","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Sysctls [NodeFeature:Sysctls] should reject invalid sysctls","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Sysctls [NodeFeature:Sysctls] should support sysctls","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Sysctls [NodeFeature:Sysctls] should support unsafe sysctls which are actually whitelisted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Variable Expansion should allow composing env vars into new env vars [NodeConformance] [Conformance]","testname":"Environment variables, expansion","file":"test/e2e/common/expansion.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Variable Expansion should allow substituting values in a container's args [NodeConformance] [Conformance]","testname":"Environment variables, command argument expansion","file":"test/e2e/common/expansion.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Variable Expansion should allow substituting values in a container's command [NodeConformance] [Conformance]","testname":"Environment variables, command expansion","file":"test/e2e/common/expansion.go","release":"1.9.0","conformance_test":true},{"test":"[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage] [Conformance]","testname":"VolumeSubpathEnvExpansion, subpath expansion","file":"test/e2e/common/expansion.go","release":"1.19.0","conformance_test":true},{"test":"[k8s.io] Variable Expansion should allow substituting values in a volume subpath [sig-storage][NodeFeature:VolumeSubpathEnvExpansion]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing mutating webhooks should work [Conformance]","testname":"Admission webhook, list mutating webhooks","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] listing validating webhooks should work [Conformance]","testname":"Admission webhook, list validating webhooks","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a mutating webhook should work [Conformance]","testname":"Admission webhook, update mutating webhook","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] patching/updating a validating webhook should work [Conformance]","testname":"Admission webhook, update validating webhook","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny attaching pod [Conformance]","testname":"Admission webhook, deny attach","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny custom resource creation, update and deletion [Conformance]","testname":"Admission webhook, deny custom resource create and delete","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should be able to deny pod and configmap creation [Conformance]","testname":"Admission webhook, deny create","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should deny crd creation [Conformance]","testname":"Admission webhook, deny custom resource definition","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should honor timeout [Conformance]","testname":"Admission webhook, honor timeout","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should include webhook resources in discovery documents [Conformance]","testname":"Admission webhook, discovery document","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate configmap [Conformance]","testname":"Admission webhook, ordered mutation","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource [Conformance]","testname":"Admission webhook, mutate custom resource","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with different stored version [Conformance]","testname":"Admission webhook, mutate custom resource with different stored version","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate custom resource with pruning [Conformance]","testname":"Admission webhook, mutate custom resource with pruning","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should mutate pod and apply defaults after mutation [Conformance]","testname":"Admission webhook, mutation with defaulting","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should not be able to mutate or prevent deletion of webhook configuration objects [Conformance]","testname":"Admission webhook, admission control not allowed on webhook configuration objects","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook [Privileged:ClusterAdmin] should unconditionally reject operations on fail closed webhook [Conformance]","testname":"Admission webhook, fail closed","file":"test/e2e/apimachinery/webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] AdmissionWebhook Should be able to deny attaching pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should be able to deny custom resource creation and deletion","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should be able to deny pod and configmap creation","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should deny crd creation","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should honor timeout","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should mutate configmap","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should mutate custom resource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should mutate custom resource with different stored version","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should mutate custom resource with pruning","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should mutate pod and apply defaults after mutation","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should not be able to mutate or prevent deletion of webhook configuration objects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] AdmissionWebhook Should unconditionally reject operations on fail closed webhook","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Aggregator Should be able to support the 1.10 Sample API Server using the current Aggregator [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Aggregator Should be able to support the 1.17 Sample API Server using the current Aggregator [Conformance]","testname":"aggregator-supports-the-sample-apiserver","file":"test/e2e/apimachinery/aggregator.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json\"","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/json,application/vnd.kubernetes.protobuf\"","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf\"","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] client-go should negotiate watch and report errors with accept \"application/vnd.kubernetes.protobuf,application/json\"","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert a non homogeneous list of CRs [Conformance]","testname":"Custom Resource Definition Conversion Webhook, convert mixed version list","file":"test/e2e/apimachinery/crd_conversion_webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourceConversionWebhook [Privileged:ClusterAdmin] should be able to convert from CR v1 to CR v2 [Conformance]","testname":"Custom Resource Definition Conversion Webhook, conversion custom resource","file":"test/e2e/apimachinery/crd_conversion_webhook.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourceConversionWebhook Should be able to convert a non homogeneous list of CRs","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourceConversionWebhook Should be able to convert from CR v1 to CR v2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] custom resource defaulting for requests and from storage works  [Conformance]","testname":"Custom Resource Definition, defaulting","file":"test/e2e/apimachinery/custom_resource_definition.go","release":"1.17.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] should include custom resource definition resources in discovery documents [Conformance]","testname":"Custom Resource Definition, discovery","file":"test/e2e/apimachinery/custom_resource_definition.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","testname":"Custom Resource Definition, create","file":"test/e2e/apimachinery/custom_resource_definition.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition getting/updating/patching custom resource definition status sub-resource works  [Conformance]","testname":"Custom Resource Definition, status sub-resource","file":"test/e2e/apimachinery/custom_resource_definition.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourceDefinition resources [Privileged:ClusterAdmin] Simple CustomResourceDefinition listing custom resource definition objects works  [Conformance]","testname":"Custom Resource Definition, list","file":"test/e2e/apimachinery/custom_resource_definition.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourceDefinition resources Simple CustomResourceDefinition creating/deleting custom resource definition objects works  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourceDefinition Watch CustomResourceDefinition Watch watch on custom resource definition objects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourceDefinition Watch [Privileged:ClusterAdmin] CustomResourceDefinition Watch watch on custom resource definition objects [Conformance]","testname":"Custom Resource Definition, watch","file":"test/e2e/apimachinery/crd_watch.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] removes definition from spec when one version gets changed to not be served [Conformance]","testname":"Custom Resource OpenAPI Publish, stop serving version","file":"test/e2e/apimachinery/crd_publish_openapi.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] updates the published spec when one version gets renamed [Conformance]","testname":"Custom Resource OpenAPI Publish, version rename","file":"test/e2e/apimachinery/crd_publish_openapi.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields at the schema root [Conformance]","testname":"Custom Resource OpenAPI Publish, with x-preserve-unknown-fields at root","file":"test/e2e/apimachinery/crd_publish_openapi.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD preserving unknown fields in an embedded object [Conformance]","testname":"Custom Resource OpenAPI Publish, with x-preserve-unknown-fields in embedded object","file":"test/e2e/apimachinery/crd_publish_openapi.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD without validation schema [Conformance]","testname":"Custom Resource OpenAPI Publish, with x-preserve-unknown-fields in object","file":"test/e2e/apimachinery/crd_publish_openapi.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for CRD with validation schema [Conformance]","testname":"Custom Resource OpenAPI Publish, with validation schema","file":"test/e2e/apimachinery/crd_publish_openapi.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of different groups [Conformance]","testname":"Custom Resource OpenAPI Publish, varying groups","file":"test/e2e/apimachinery/crd_publish_openapi.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group and version but different kinds [Conformance]","testname":"Custom Resource OpenAPI Publish, varying kinds","file":"test/e2e/apimachinery/crd_publish_openapi.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI [Privileged:ClusterAdmin] works for multiple CRDs of same group but different versions [Conformance]","testname":"Custom Resource OpenAPI Publish, varying versions","file":"test/e2e/apimachinery/crd_publish_openapi.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI removes definition from spec when one versin gets changed to not be served","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI updates the published spec when one versin gets renamed","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI works for CRD preserving unknown fields at the schema root","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI works for CRD preserving unknown fields in an embedded object","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI works for CRD without validation schema","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI works for CRD with validation schema","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI works for multiple CRDs of different groups","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI works for multiple CRDs of same group and version but different kinds","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] CustomResourcePublishOpenAPI works for multiple CRDs of same group but different versions","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Discovery Custom resource should have storage version hash","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Events should delete a collection of events","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Events should ensure that an event can be fetched, patched, deleted, and listed [Conformance]","testname":"Event resource lifecycle","file":"test/e2e/apimachinery/events.go","release":"1.19.0","conformance_test":true},{"test":"[sig-api-machinery] Garbage collector should delete jobs and pods created by cronjob","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Garbage collector should delete pods created by rc when not orphaning [Conformance]","testname":"Garbage Collector, delete replication controller, propagation policy background","file":"test/e2e/apimachinery/garbage_collector.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Garbage collector should delete RS created by deployment when not orphaning [Conformance]","testname":"Garbage Collector, delete deployment,  propagation policy background","file":"test/e2e/apimachinery/garbage_collector.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Garbage collector should keep the rc around until all its pods are deleted if the deleteOptions says so [Conformance]","testname":"Garbage Collector, delete replication controller, after owned pods","file":"test/e2e/apimachinery/garbage_collector.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Garbage collector should not be blocked by dependency circle [Conformance]","testname":"Garbage Collector, dependency cycle","file":"test/e2e/apimachinery/garbage_collector.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Garbage collector should not delete dependents that have both valid owner and owner that's waiting for dependents to be deleted [Conformance]","testname":"Garbage Collector, multiple owners","file":"test/e2e/apimachinery/garbage_collector.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Garbage collector should orphan pods created by rc if deleteOptions.OrphanDependents is nil","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Garbage collector should orphan pods created by rc if delete options say so [Conformance]","testname":"Garbage Collector, delete replication controller, propagation policy orphan","file":"test/e2e/apimachinery/garbage_collector.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Garbage collector should orphan RS created by deployment when deleteOptions.PropagationPolicy is Orphan [Conformance]","testname":"Garbage Collector, delete deployment, propagation policy orphan","file":"test/e2e/apimachinery/garbage_collector.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Garbage collector should support cascading deletion of custom resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Garbage collector should support orphan deletion of custom resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Generated clientset should create pods, set the deletionTimestamp and deletionGracePeriodSeconds of the pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Generated clientset should create v1beta1 cronJobs, delete cronJobs, watch cronJobs","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota Should be able to update and delete ResourceQuota.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should be able to update and delete ResourceQuota. [Conformance]","testname":"ResourceQuota, update and delete","file":"test/e2e/apimachinery/resource_quota.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a configMap. [Conformance]","testname":"ResourceQuota, object count quota, configmap","file":"test/e2e/apimachinery/resource_quota.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a custom resource.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim. [sig-storage]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a persistent volume claim with a storage class. [sig-storage]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a pod. [Conformance]","testname":"ResourceQuota, object count quota, pod","file":"test/e2e/apimachinery/resource_quota.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replica set. [Conformance]","testname":"ResourceQuota, object count quota, replicaSet","file":"test/e2e/apimachinery/resource_quota.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a replication controller. [Conformance]","testname":"ResourceQuota, object count quota, replicationController","file":"test/e2e/apimachinery/resource_quota.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a secret. [Conformance]","testname":"ResourceQuota, object count quota, secret","file":"test/e2e/apimachinery/resource_quota.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and capture the life of a service. [Conformance]","testname":"ResourceQuota, object count quota, service","file":"test/e2e/apimachinery/resource_quota.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should create a ResourceQuota and ensure its status is promptly calculated. [Conformance]","testname":"ResourceQuota, object count quota, resourcequotas","file":"test/e2e/apimachinery/resource_quota.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should verify ResourceQuota with best effort scope. [Conformance]","testname":"ResourceQuota, quota scope, BestEffort and NotBestEffort scope","file":"test/e2e/apimachinery/resource_quota.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] ResourceQuota should verify ResourceQuota with terminating scopes. [Conformance]","testname":"ResourceQuota, quota scope, Terminating and NotTerminating scope","file":"test/e2e/apimachinery/resource_quota.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] Secrets should be consumable from pods in env vars [NodeConformance] [Conformance]","testname":"Secrets, pod environment field","file":"test/e2e/common/secrets.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Secrets should be consumable via the environment [NodeConformance] [Conformance]","testname":"Secrets, pod environment from source","file":"test/e2e/common/secrets.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Secrets should fail to create secret due to empty secret key [Conformance]","testname":"Secrets, with empty-key","file":"test/e2e/common/secrets.go","release":"1.15.0","conformance_test":true},{"test":"[sig-api-machinery] Secrets should patch a secret [Conformance]","testname":"Secret patching","file":"test/e2e/common/secrets.go","release":"1.18.0","conformance_test":true},{"test":"[sig-api-machinery] Servers with support for API chunking should return chunks of results for list calls","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Servers with support for API chunking should support continue listing from the last key if the original version has been compacted away, though the list is inconsistent","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Servers with support for Table transformation should return a 406 for a backend which does not implement metadata [Conformance]","testname":"API metadata HTTP return","file":"test/e2e/apimachinery/table_conversion.go","release":"1.16.0","conformance_test":true},{"test":"[sig-api-machinery] Servers with support for Table transformation should return chunks of table results for list calls","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Servers with support for Table transformation should return generic metadata details across all namespaces for nodes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Servers with support for Table transformation should return pod details","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-api-machinery] Watchers should be able to restart watching from the last resource version observed by the previous watch [Conformance]","testname":"watch-configmaps-closed-and-restarted","file":"test/e2e/apimachinery/watch.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Watchers should be able to start watching from a specific resource version [Conformance]","testname":"watch-configmaps-from-resource-version","file":"test/e2e/apimachinery/watch.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Watchers should observe add, update, and delete watch notifications on configmaps [Conformance]","testname":"watch-configmaps-with-multiple-watchers","file":"test/e2e/apimachinery/watch.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Watchers should observe an object deletion if it stops meeting the requirements of the selector [Conformance]","testname":"watch-configmaps-label-changed","file":"test/e2e/apimachinery/watch.go","release":"1.9.0","conformance_test":true},{"test":"[sig-api-machinery] Watchers should receive events on concurrent watches in same order [Conformance]","testname":"watch-consistency","file":"test/e2e/apimachinery/watch.go","release":"1.15.0","conformance_test":true},{"test":"[sig-apps] CronJob should delete failed finished jobs with limit of one job","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] CronJob should delete successful/failed finished jobs with limit of one job","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] CronJob should delete successful finished jobs with limit of one successful job","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] CronJob should not emit unexpected warnings","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] CronJob should remove from active list jobs that have been deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] CronJob should replace jobs when ReplaceConcurrent","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] CronJob should schedule multiple jobs concurrently","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Deployment deployment reaping should cascade to its replica sets and pods","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Deployment deployment should delete old replica sets [Conformance]","testname":"Deployment RevisionHistoryLimit","file":"test/e2e/apps/deployment.go","release":"1.9.0","conformance_test":true},{"test":"[sig-apps] Deployment deployment should support proportional scaling [Conformance]","testname":"Deployment Proportional Scaling","file":"test/e2e/apps/deployment.go","release":"1.9.0","conformance_test":true},{"test":"[sig-apps] Deployment deployment should support rollback","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Deployment deployment should support rollover [Conformance]","testname":"Deployment Rollover","file":"test/e2e/apps/deployment.go","release":"1.9.0","conformance_test":true},{"test":"[sig-apps] Deployment iterative rollouts should eventually progress","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Deployment RecreateDeployment should delete old pods and create new ones [Conformance]","testname":"Deployment Recreate","file":"test/e2e/apps/deployment.go","release":"1.9.0","conformance_test":true},{"test":"[sig-apps] Deployment RollingUpdateDeployment should delete old pods and create new ones [Conformance]","testname":"Deployment RollingUpdate","file":"test/e2e/apps/deployment.go","release":"1.9.0","conformance_test":true},{"test":"[sig-apps] Deployment should not disrupt a cloud load-balancer's connectivity during rollout","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Deployment test Deployment ReplicaSet orphaning and adoption regarding controllerRef","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController evictions: enough pods, absolute => should allow an eviction","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController evictions: enough pods, replicaSet, percentage => should allow an eviction","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController evictions: maxUnavailable allow single eviction, percentage => should allow an eviction","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController evictions: maxUnavailable deny evictions, integer => should not allow an eviction","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController evictions: no PDB => should allow an eviction","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController evictions: too few pods, absolute => should not allow an eviction","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController evictions: too few pods, replicaSet, percentage => should not allow an eviction","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController Listing PodDisruptionBudgets for all namespaces should list and delete a collection of PodDisruptionBudgets","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController should block an eviction until the PDB is updated to allow it","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController should create a PodDisruptionBudget","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController should observe PodDisruptionBudget status updated","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController should update/patch PodDisruptionBudget status","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] DisruptionController should update PodDisruptionBudget status","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Job should adopt matching orphans and release non-matching pods","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Job should adopt matching orphans and release non-matching pods [Conformance]","testname":"Jobs, orphan pods, re-adoption","file":"test/e2e/apps/job.go","release":"1.16.0","conformance_test":true},{"test":"[sig-apps] Job should delete a job [Conformance]","testname":"Jobs, active pods, graceful termination","file":"test/e2e/apps/job.go","release":"1.15.0","conformance_test":true},{"test":"[sig-apps] Job should exceed active deadline","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Job should exceed backoffLimit","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Job should fail to exceed backoffLimit","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Job should fail when exceeds active deadline","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Job should remove pods when job is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Job should run a job to completion when tasks sometimes fail and are locally restarted [Conformance]","testname":"Jobs, completion after task failure","file":"test/e2e/apps/job.go","release":"1.16.0","conformance_test":true},{"test":"[sig-apps] Job should run a job to completion when tasks sometimes fail and are not locally restarted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] Job should run a job to completion when tasks succeed","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] ReplicaSet should adopt matching pods on creation and release no longer matching pods [Conformance]","testname":"Replica Set, adopt matching pods and release non matching pods","file":"test/e2e/apps/replica_set.go","release":"1.13.0","conformance_test":true},{"test":"[sig-apps] ReplicaSet should serve a basic image on each replica with a private image","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] ReplicaSet should serve a basic image on each replica with a public image  [Conformance]","testname":"Replica Set, run basic image","file":"test/e2e/apps/replica_set.go","release":"1.9.0","conformance_test":true},{"test":"[sig-apps] ReplicaSet should surface a failure condition on a common issue like exceeded quota","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] ReplicationController should adopt matching pods on creation [Conformance]","testname":"Replication Controller, adopt matching pods","file":"test/e2e/apps/rc.go","release":"1.13.0","conformance_test":true},{"test":"[sig-apps] ReplicationController should release no longer matching pods [Conformance]","testname":"Replication Controller, release pods","file":"test/e2e/apps/rc.go","release":"1.13.0","conformance_test":true},{"test":"[sig-apps] ReplicationController should serve a basic image on each replica with a private image","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] ReplicationController should serve a basic image on each replica with a public image  [Conformance]","testname":"Replication Controller, run basic image","file":"test/e2e/apps/rc.go","release":"1.9.0","conformance_test":true},{"test":"[sig-apps] ReplicationController should surface a failure condition on a common issue like exceeded quota [Conformance]","testname":"Replication Controller, check for issues like exceeding allocated quota","file":"test/e2e/apps/rc.go","release":"1.15.0","conformance_test":true},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Burst scaling should run to completion even with unhealthy pods [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Scaling should happen in predictable order and halt if any stateful pod is unhealthy [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should adopt matching orphans and release non-matching pods","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should have a working scale subresource [Conformance]","testname":"StatefulSet resource Replica scaling","file":"test/e2e/apps/statefulset.go","release":"1.16.0","conformance_test":true},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should implement legacy replacement when the update strategy is OnDelete","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should not deadlock when a pod's predecessor fails","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform canary updates and phased rolling updates of template modifications [Conformance]","testname":"StatefulSet, Rolling Update with Partition","file":"test/e2e/apps/statefulset.go","release":"1.9.0","conformance_test":true},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications [Conformance]","testname":"StatefulSet, Rolling Update","file":"test/e2e/apps/statefulset.go","release":"1.9.0","conformance_test":true},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should perform rolling updates and roll backs of template modifications with PVCs","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] should provide basic identity","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-apps] StatefulSet [k8s.io] Basic StatefulSet functionality [StatefulSetBasic] Should recreate evicted statefulset [Conformance]","testname":"StatefulSet, Recreate Failed Pod","file":"test/e2e/apps/statefulset.go","release":"1.9.0","conformance_test":true},{"test":"[sig-architecture] PodTemplates should run the lifecycle of PodTemplates","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-auth] Certificates API [Privileged:ClusterAdmin] should support building a client with a CSR","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-auth] Certificates API [Privileged:ClusterAdmin] should support CSR API operations [Conformance]","testname":"CertificateSigningRequest API","file":"test/e2e/auth/certificates.go","release":"1.19.0","conformance_test":true},{"test":"[sig-auth] Certificates API should support building a client with a CSR","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-auth] Metadata Concealment should run a check-metadata-concealment job to completion","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-auth] PodSecurityPolicy should allow pods under the privileged policy.PodSecurityPolicy","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-auth] PodSecurityPolicy should enforce the restricted policy.PodSecurityPolicy","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-auth] PodSecurityPolicy should forbid pod creation when no PSP is available","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-auth] ServiceAccounts should allow opting out of API token automount  [Conformance]","testname":"Service account tokens auto mount optionally","file":"test/e2e/auth/service_accounts.go","release":"1.9.0","conformance_test":true},{"test":"[sig-auth] ServiceAccounts should ensure a single API token exists","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-auth] ServiceAccounts should mount an API token into pods  [Conformance]","testname":"Service Account Tokens Must AutoMount","file":"test/e2e/auth/service_accounts.go","release":"1.9.0","conformance_test":true},{"test":"[sig-auth] ServiceAccounts should run through the lifecycle of a ServiceAccount [Conformance]","testname":"ServiceAccount lifecycle test","file":"test/e2e/auth/service_accounts.go","release":"1.19.0","conformance_test":true},{"test":"[sig-autoscaling] DNS horizontal autoscaling [DisabledForLargeClusters] kube-dns-autoscaler should scale kube-dns pods in both nonfaulty and faulty scenarios","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] ReplicationController light Should scale from 1 pod to 2 pods","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-autoscaling] [HPA] Horizontal pod autoscaling (scale resource: CPU) [sig-autoscaling] ReplicationController light Should scale from 2 pods to 1 pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl alpha client [k8s.io] Kubectl run CronJob should create a CronJob","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl alpha client Kubectl run CronJob should create a CronJob","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Guestbook application should create and stop a working application  [Conformance]","testname":"Kubectl, guestbook application","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client [k8s.io] Guestbook application should create and stop a working application  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl api-versions should check if v1 is in available api versions  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl apply apply set/view last-applied","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl apply should apply a new configuration to an existing RC","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl apply should reuse port when apply to an existing SVC","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl cluster-info dump should check if cluster-info dump succeeds","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl copy should copy a file from a running Pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl create quota should create a quota without scopes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl create quota should create a quota with scopes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl create quota should reject quota with invalid scopes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl expose should create services for rc  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl get componentstatuses should get componentstatuses","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl label should update the label on a resource  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl logs should be able to retrieve and filter logs  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl patch should add annotations for pods in rc  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl replace should update a single-container pod's image  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl rolling-update should support rolling-update to same image  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl run","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl run CronJob should create a CronJob","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl run default should create an rc or deployment from an image  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl run deployment should create a deployment from an image  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl run job should create a job from an image when restart is OnFailure  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl run rc should create an rc from an image  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Kubectl version should check is all data is printed  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Proxy server should support","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Proxy server should support proxy with","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Simple pod should contain last line of the log","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Simple pod should handle in-cluster config","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Simple pod should return command exit codes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Simple pod should support exec","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Simple pod should support exec through an HTTP proxy","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Simple pod should support exec through kubectl proxy","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Simple pod should support exec using resource/name","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Simple pod should support inline execution and attach","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Simple pod should support port-forward","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Update Demo should create and stop a replication controller  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Update Demo should do a rolling update of a replication controller  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client [k8s.io] Update Demo should scale a replication controller  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl api-versions should check if v1 is in available api versions  [Conformance]","testname":"Kubectl, check version v1","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl apply apply set/view last-applied","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl apply should apply a new configuration to an existing RC","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl apply should reuse port when apply to an existing SVC","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl client-side validation should create/apply a CR with unknown fields for CRD with no validation schema","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR for CRD with validation schema","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl client-side validation should create/apply a valid CR with arbitrary-extra properties for CRD with partially-specified validation schema","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl cluster-info dump should check if cluster-info dump succeeds","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl cluster-info should check if Kubernetes master services is included in cluster-info  [Conformance]","testname":"Kubectl, cluster info","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl copy should copy a file from a running Pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl create quota should create a quota without scopes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl create quota should create a quota with scopes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl create quota should reject quota with invalid scopes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for cronjob","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl describe should check if kubectl describe prints relevant information for rc and pods  [Conformance]","testname":"Kubectl, describe pod or rc","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl diff should check if kubectl diff finds a difference for Deployments [Conformance]","testname":"Kubectl, diff Deployment","file":"test/e2e/kubectl/kubectl.go","release":"1.19.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl expose should create services for rc  [Conformance]","testname":"Kubectl, create service, replication controller","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl get componentstatuses should get componentstatuses","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl label should update the label on a resource  [Conformance]","testname":"Kubectl, label update","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl logs should be able to retrieve and filter logs  [Conformance]","testname":"Kubectl, logs","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl patch should add annotations for pods in rc  [Conformance]","testname":"Kubectl, patch to annotate","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl replace should update a single-container pod's image  [Conformance]","testname":"Kubectl, replace","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl rolling-update should support rolling-update to same image  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl run","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl run CronJob should create a CronJob","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl run default should create an rc or deployment from an image  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl run deployment should create a deployment from an image  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl run job should create a job from an image when restart is OnFailure  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl run pod should create a pod from an image when restart is Never  [Conformance]","testname":"Kubectl, run pod","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl run rc should create an rc from an image  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Kubectl server-side dry-run should check if kubectl can dry-run update Pods [Conformance]","testname":"Kubectl, server-side dry-run Pod","file":"test/e2e/kubectl/kubectl.go","release":"1.19.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Kubectl version should check is all data is printed  [Conformance]","testname":"Kubectl, version","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Proxy server should support","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Proxy server should support proxy with","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Simple pod should contain last line of the log","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Simple pod should handle in-cluster config","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Simple pod should return command exit codes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Simple pod should support exec","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Simple pod should support exec through an HTTP proxy","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Simple pod should support exec through kubectl proxy","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Simple pod should support exec using resource/name","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Simple pod should support inline execution and attach","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Simple pod should support port-forward","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Update Demo should create and stop a replication controller  [Conformance]","testname":"Kubectl, replication controller","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl client Update Demo should do a rolling update of a replication controller  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl client Update Demo should scale a replication controller  [Conformance]","testname":"Kubectl, scale replication controller","file":"test/e2e/kubectl/kubectl.go","release":"1.9.0","conformance_test":true},{"test":"[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 [k8s.io] that expects a client request should support a client that connects, sends DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 [k8s.io] that expects a client request should support a client that connects, sends NO DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 [k8s.io] that expects NO client request should support a client that connects, sends DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on 0.0.0.0 should support forwarding over websockets","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost [k8s.io] that expects a client request should support a client that connects, sends DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost [k8s.io] that expects a client request should support a client that connects, sends NO DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost [k8s.io] that expects NO client request should support a client that connects, sends DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding [k8s.io] With a server listening on localhost should support forwarding over websockets","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 should support forwarding over websockets","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects a client request should support a client that connects, sends NO DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding With a server listening on 0.0.0.0 that expects NO client request should support a client that connects, sends DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding With a server listening on localhost should support forwarding over websockets","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects a client request should support a client that connects, sends NO DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-cli] Kubectl Port forwarding With a server listening on localhost that expects NO client request should support a client that connects, sends DATA, and disconnects","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-instrumentation] Cadvisor should be healthy on every node.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-instrumentation] MetricsGrabber should grab all metrics from a ControllerManager.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-instrumentation] MetricsGrabber should grab all metrics from a Kubelet.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-instrumentation] MetricsGrabber should grab all metrics from API server.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-instrumentation] MetricsGrabber should grab all metrics from a Scheduler.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a ClusterIP service","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Conntrack should be able to preserve UDP traffic when server pod cycles for a NodePort service","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] DNS should provide DNS for ExternalName services [Conformance]","testname":"DNS, for ExternalName Services","file":"test/e2e/network/dns.go","release":"1.15.0","conformance_test":true},{"test":"[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] DNS should provide DNS for pods for Hostname [LinuxOnly] [Conformance]","testname":"DNS, resolve the hostname","file":"test/e2e/network/dns.go","release":"1.15.0","conformance_test":true},{"test":"[sig-network] DNS should provide DNS for pods for Subdomain","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] DNS should provide DNS for pods for Subdomain [Conformance]","testname":"DNS, resolve the subdomain","file":"test/e2e/network/dns.go","release":"1.15.0","conformance_test":true},{"test":"[sig-network] DNS should provide DNS for services  [Conformance]","testname":"DNS, services","file":"test/e2e/network/dns.go","release":"1.9.0","conformance_test":true},{"test":"[sig-network] DNS should provide DNS for the cluster  [Conformance]","testname":"DNS, cluster","file":"test/e2e/network/dns.go","release":"1.9.0","conformance_test":true},{"test":"[sig-network] DNS should provide DNS for the cluster [Provider:GCE]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] DNS should provide /etc/hosts entries for the cluster [LinuxOnly] [Conformance]","testname":"DNS, cluster","file":"test/e2e/network/dns.go","release":"1.14.0","conformance_test":true},{"test":"[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] DNS should resolve DNS of partial qualified names for services [LinuxOnly] [Conformance]","testname":"DNS, PQDN for services","file":"test/e2e/network/dns.go","release":"1.17.0","conformance_test":true},{"test":"[sig-network] DNS should resolve DNS of partial qualified names for the cluster [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] DNS should support configurable pod DNS nameservers","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] DNS should support configurable pod DNS nameservers [Conformance]","testname":"DNS, custom dnsConfig","file":"test/e2e/network/dns.go","release":"1.17.0","conformance_test":true},{"test":"[sig-network] DNS should support configurable pod resolv.conf","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] EndpointSlice should create and delete Endpoints and EndpointSlices for a Service with a selector specified","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] EndpointSlice should create Endpoints and EndpointSlices for Pods matching a Service","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] EndpointSlice should have Endpoints and EndpointSlices pointing to API Server","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Firewall rule should have correct firewall rules for e2e cluster","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Ingress API should support creating Ingress API operations [Conformance]","testname":"Ingress API","file":"test/e2e/network/ingress.go","release":"1.19.0","conformance_test":true},{"test":"[sig-network] IngressClass API  should support creating IngressClass API operations [Conformance]","testname":"IngressClass API","file":"test/e2e/network/ingressclass.go","release":"1.19.0","conformance_test":true},{"test":"[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: http [NodeConformance] [Conformance]","testname":"Networking, intra pod http","file":"test/e2e/common/networking.go","release":"1.18.0","conformance_test":true},{"test":"[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Pods should function for intra-pod communication: udp [NodeConformance] [Conformance]","testname":"Networking, intra pod udp","file":"test/e2e/common/networking.go","release":"1.18.0","conformance_test":true},{"test":"[sig-network] Networking Granular Checks: Pods should function for node-pod communication: http [LinuxOnly] [NodeConformance] [Conformance]","testname":"Networking, intra pod http, from node","file":"test/e2e/common/networking.go","release":"1.9.0","conformance_test":true},{"test":"[sig-network] Networking Granular Checks: Pods should function for node-pod communication: udp [LinuxOnly] [NodeConformance] [Conformance]","testname":"Networking, intra pod http, from node","file":"test/e2e/common/networking.go","release":"1.9.0","conformance_test":true},{"test":"[sig-network] Networking Granular Checks: Services should be able to handle large requests: http","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should be able to handle large requests: udp","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: http [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should function for client IP based session affinity: udp [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should function for endpoint-Service: http","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should function for endpoint-Service: udp","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should function for node-Service: http","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should function for node-Service: udp","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should function for pod-Service: http","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should function for pod-Service: udp","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should update endpoints: http","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking Granular Checks: Services should update endpoints: udp","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking should check kube-proxy urls","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Networking should provide unchanging, static URL paths for kubernetes api services","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Network should set TCP CLOSE_WAIT timeout","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Network should set TCP CLOSE_WAIT timeout [Privileged]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Proxy version v1 should proxy logs on node using proxy subresource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Proxy version v1 should proxy logs on node using proxy subresource  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Proxy version v1 should proxy logs on node with explicit kubelet port using proxy subresource  [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Proxy version v1 should proxy through a service and a pod  [Conformance]","testname":"Proxy, logs service endpoint","file":"test/e2e/network/proxy.go","release":"1.9.0","conformance_test":true},{"test":"[sig-network] Service endpoints latency should not be very high  [Conformance]","testname":"Service endpoint latency, thresholds","file":"test/e2e/network/service_latency.go","release":"1.9.0","conformance_test":true},{"test":"[sig-network] Services should allow pods to hairpin back to themselves through services","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to change the type from ClusterIP to ExternalName","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to change the type from ClusterIP to ExternalName [Conformance]","testname":"Service, change type, ClusterIP to ExternalName","file":"test/e2e/network/service.go","release":"1.16.0","conformance_test":true},{"test":"[sig-network] Services should be able to change the type from ExternalName to ClusterIP","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to change the type from ExternalName to ClusterIP [Conformance]","testname":"Service, change type, ExternalName to ClusterIP","file":"test/e2e/network/service.go","release":"1.16.0","conformance_test":true},{"test":"[sig-network] Services should be able to change the type from ExternalName to NodePort","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to change the type from ExternalName to NodePort [Conformance]","testname":"Service, change type, ExternalName to NodePort","file":"test/e2e/network/service.go","release":"1.16.0","conformance_test":true},{"test":"[sig-network] Services should be able to change the type from NodePort to ExternalName","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to change the type from NodePort to ExternalName [Conformance]","testname":"Service, change type, NodePort to ExternalName","file":"test/e2e/network/service.go","release":"1.16.0","conformance_test":true},{"test":"[sig-network] Services should be able to create a functioning NodePort service","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to create a functioning NodePort service [Conformance]","testname":"Service, NodePort Service","file":"test/e2e/network/service.go","release":"1.16.0","conformance_test":true},{"test":"[sig-network] Services should be able to switch session affinity for NodePort service","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to switch session affinity for NodePort service [LinuxOnly] [Conformance]","testname":"Service, NodePort type, session affinity to None","file":"test/e2e/network/service.go","release":"1.19.0","conformance_test":true},{"test":"[sig-network] Services should be able to switch session affinity for service with type clusterIP","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to switch session affinity for service with type clusterIP [LinuxOnly] [Conformance]","testname":"Service, ClusterIP type, session affinity to None","file":"test/e2e/network/service.go","release":"1.19.0","conformance_test":true},{"test":"[sig-network] Services should be able to up and down services","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to update NodePorts with two same port numbers but different protocols","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be able to update service type to NodePort listening on same port number but different protocols","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should be rejected when no endpoints exist","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should check NodePort out-of-range","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should create endpoints for unready pods","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should find a service from listing all namespaces [Conformance]","testname":"Find Kubernetes Service in default Namespace","file":"test/e2e/network/service.go","release":"1.18.0","conformance_test":true},{"test":"[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should have session affinity timeout work for NodePort service [LinuxOnly] [Conformance]","testname":"Service, NodePort type, session affinity to ClientIP with timeout","file":"test/e2e/network/service.go","release":"1.19.0","conformance_test":true},{"test":"[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should have session affinity timeout work for service with type clusterIP [LinuxOnly] [Conformance]","testname":"Service, ClusterIP type, session affinity to ClientIP with timeout","file":"test/e2e/network/service.go","release":"1.19.0","conformance_test":true},{"test":"[sig-network] Services should have session affinity work for NodePort service","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should have session affinity work for NodePort service [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should have session affinity work for NodePort service [LinuxOnly] [Conformance]","testname":"Service, NodePort type, session affinity to ClientIP","file":"test/e2e/network/service.go","release":"1.19.0","conformance_test":true},{"test":"[sig-network] Services should have session affinity work for service with type clusterIP","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should have session affinity work for service with type clusterIP [LinuxOnly] [Conformance]","testname":"Service, ClusterIP type, session affinity to ClientIP","file":"test/e2e/network/service.go","release":"1.19.0","conformance_test":true},{"test":"[sig-network] Services should implement service.kubernetes.io/headless","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should implement service.kubernetes.io/service-proxy-name","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should preserve source pod IP for traffic thru service cluster IP","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should preserve source pod IP for traffic thru service cluster IP [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should prevent NodePort collisions","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should provide secure master service  [Conformance]","testname":"Kubernetes Service","file":"test/e2e/network/service.go","release":"1.9.0","conformance_test":true},{"test":"[sig-network] Services should release NodePorts on delete","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should serve a basic endpoint from pods  [Conformance]","testname":"Service, endpoints","file":"test/e2e/network/service.go","release":"1.9.0","conformance_test":true},{"test":"[sig-network] Services should serve multiport endpoints from pods  [Conformance]","testname":"Service, endpoints with multiple ports","file":"test/e2e/network/service.go","release":"1.9.0","conformance_test":true},{"test":"[sig-network] Services should test the lifecycle of an Endpoint","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] Services should use same NodePort with same port but different protocols","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: http","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] [sig-windows] Networking Granular Checks: Pods should function for intra-pod communication: udp","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: http","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-network] [sig-windows] Networking Granular Checks: Pods should function for node-pod communication: udp","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] ConfigMap should be consumable via environment variable [NodeConformance] [Conformance]","testname":"ConfigMap, from environment field","file":"test/e2e/common/configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-node] ConfigMap should be consumable via the environment [NodeConformance] [Conformance]","testname":"ConfigMap, from environment variables","file":"test/e2e/common/configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-node] ConfigMap should fail to create ConfigMap with empty key [Conformance]","testname":"ConfigMap, with empty-key","file":"test/e2e/common/configmap.go","release":"1.14.0","conformance_test":true},{"test":"[sig-node] ConfigMap should patch ConfigMap successfully","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] ConfigMap should run through a ConfigMap lifecycle","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] ConfigMap should update ConfigMap successfully","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] Downward API should provide container's limits.cpu/memory and requests.cpu/memory as env vars [NodeConformance] [Conformance]","testname":"DownwardAPI, environment for CPU and memory limits and requests","file":"test/e2e/common/downward_api.go","release":"1.9.0","conformance_test":true},{"test":"[sig-node] Downward API should provide default limits.cpu/memory from node allocatable [NodeConformance] [Conformance]","testname":"DownwardAPI, environment for default CPU and memory limits and requests","file":"test/e2e/common/downward_api.go","release":"1.9.0","conformance_test":true},{"test":"[sig-node] Downward API should provide host IP and pod IP as an env var if pod uses host network [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] Downward API should provide host IP as an env var [NodeConformance] [Conformance]","testname":"DownwardAPI, environment for host ip","file":"test/e2e/common/downward_api.go","release":"1.9.0","conformance_test":true},{"test":"[sig-node] Downward API should provide pod name, namespace and IP address as env vars [NodeConformance] [Conformance]","testname":"DownwardAPI, environment for name, namespace and ip","file":"test/e2e/common/downward_api.go","release":"1.9.0","conformance_test":true},{"test":"[sig-node] Downward API should provide pod UID as env vars [NodeConformance] [Conformance]","testname":"DownwardAPI, environment for Pod UID","file":"test/e2e/common/downward_api.go","release":"1.9.0","conformance_test":true},{"test":"[sig-node] PodTemplates should delete a collection of pod templates","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] PodTemplates should run the lifecycle of PodTemplates [Conformance]","testname":"PodTemplate lifecycle","file":"test/e2e/common/podtemplates.go","release":"1.19.0","conformance_test":true},{"test":"[sig-node] RuntimeClass should reject a Pod requesting a deleted RuntimeClass","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] RuntimeClass should reject a Pod requesting a non-existent RuntimeClass","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with an unconfigured handler","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] RuntimeClass should reject a Pod requesting a RuntimeClass with conflicting node selector","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with a configured handler [NodeFeature:RuntimeHandler]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-node] RuntimeClass should run a Pod requesting a RuntimeClass with scheduling [NodeFeature:RuntimeHandler]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-scheduling] LimitRange should create a LimitRange with defaults and ensure pod has those defaults applied. [Conformance]","testname":"LimitRange, resources","file":"test/e2e/scheduling/limit_range.go","release":"1.18.0","conformance_test":true},{"test":"[sig-scheduling] Multi-AZ Clusters should spread the pods of a replication controller across zones","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-scheduling] Multi-AZ Clusters should spread the pods of a service across zones","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should only be allowed to provision PDs in zones where nodes exist","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-scheduling] Multi-AZ Cluster Volumes [sig-storage] should schedule pods in the same zones as statically provisioned PVs","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-scheduling] PreemptionExecutionPath runs ReplicaSets to verify preemption running path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] ConfigMap binary data should be reflected in volume [NodeConformance] [Conformance]","testname":"ConfigMap Volume, text data, binary data","file":"test/e2e/common/configmap_volume.go","release":"1.12.0","conformance_test":true},{"test":"[sig-storage] ConfigMap optional updates should be reflected in volume [NodeConformance] [Conformance]","testname":"ConfigMap Volume, create, update and delete","file":"test/e2e/common/configmap_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","testname":"ConfigMap Volume, without mapping, non-root user","file":"test/e2e/common/configmap_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume as non-root with FSGroup [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume [NodeConformance] [Conformance]","testname":"ConfigMap Volume, without mapping","file":"test/e2e/common/configmap_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","testname":"ConfigMap Volume, without mapping, volume mode set","file":"test/e2e/common/configmap_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","testname":"ConfigMap Volume, with mapping, volume mode set","file":"test/e2e/common/configmap_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","testname":"ConfigMap Volume, with mapping, non-root user","file":"test/e2e/common/configmap_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume with mappings as non-root with FSGroup [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] ConfigMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","testname":"ConfigMap Volume, with mapping","file":"test/e2e/common/configmap_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] ConfigMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","testname":"ConfigMap Volume, multiple volume maps","file":"test/e2e/common/configmap_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] ConfigMap should be immutable if `immutable` field is set","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] ConfigMap updates should be reflected in volume [NodeConformance] [Conformance]","testname":"ConfigMap Volume, update","file":"test/e2e/common/configmap_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] CSI mock volume CSI attach test using mock driver should not require VolumeAttach for drivers without attachment","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI attach test using mock driver should preserve attachment policy when no CSIDriver present","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI attach test using mock driver should require VolumeAttach for drivers with attachment","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=off, nodeExpansion=on","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI online volume expansion should expand volume without restarting pod if attach=on, nodeExpansion=on","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=off, nodeExpansion=on","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI Volume expansion should expand volume by restarting pod if attach=on, nodeExpansion=on","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI Volume expansion should expand volume without restarting pod if nodeExpansion=off","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI Volume expansion should not expand volume if resizingOnDriver=off, resizingOnSC=on","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI workload information using mock driver contain ephemeral=true when using inline volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI workload information using mock driver should be passed when podInfoOnMount=true","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when CSIDriver does not exist","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=false","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume CSI workload information using mock driver should not be passed when podInfoOnMount=nil","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume storage capacity exhausted, immediate binding","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume storage capacity exhausted, late binding, no topology","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume storage capacity exhausted, late binding, with topology","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI mock volume storage capacity unlimited","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with mount options","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should access volume from different nodes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with defaults","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read-only inline ephemeral volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should create read/write inline ephemeral volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support multiple inline ephemeral volumes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath] [Testpattern: inline ephemeral CSI volume] ephemeral should support two pods which share the same volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (block volmode)] volumeMode should fail in binding dynamic provisioned PV to PVC","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] provisioning should access volume from different nodes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with defaults","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] CSI Volumes [Driver: csi-hostpath-v0] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Downward API volume should provide container's cpu limit [NodeConformance] [Conformance]","testname":"DownwardAPI volume, CPU limits","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Downward API volume should provide container's cpu request [NodeConformance] [Conformance]","testname":"DownwardAPI volume, CPU request","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Downward API volume should provide container's memory limit [NodeConformance] [Conformance]","testname":"DownwardAPI volume, memory limits","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Downward API volume should provide container's memory request [NodeConformance] [Conformance]","testname":"DownwardAPI volume, memory request","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Downward API volume should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","testname":"DownwardAPI volume, CPU limit, default node allocatable","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Downward API volume should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","testname":"DownwardAPI volume, memory limit, default node allocatable","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Downward API volume should provide podname as non-root with fsgroup and defaultMode [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Downward API volume should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Downward API volume should provide podname as non-root with fsgroup [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Downward API volume should provide podname only [NodeConformance] [Conformance]","testname":"DownwardAPI volume, pod name","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Downward API volume should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","testname":"DownwardAPI volume, volume mode 0400","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Downward API volume should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","testname":"DownwardAPI volume, file mode 0400","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Downward API volume should update annotations on modification [NodeConformance] [Conformance]","testname":"DownwardAPI volume, update annotations","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Downward API volume should update labels on modification [NodeConformance] [Conformance]","testname":"DownwardAPI volume, update label","file":"test/e2e/common/downwardapi_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Dynamic Provisioning DynamicProvisioner allowedTopologies should create persistent volume in the zone specified in allowedTopologies of storageclass","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Dynamic Provisioning Invalid AWS KMS key should report an error and create no PV","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Dynamic Provisioning [k8s.io] GlusterDynamicProvisioner should create and delete persistent volumes [fast]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes pod should support shared volumes between containers [Conformance]","testname":"EmptyDir, Shared volumes between containers","file":"test/e2e/common/empty_dir.go","release":"1.15.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (non-root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium default, volume mode 0644","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (non-root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium memory, volume mode 0644, non-root user","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (non-root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium default, volume mode 0666","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (non-root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium memory, volume mode 0666,, non-root user","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (non-root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium default, volume mode 0777","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (non-root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium memory, volume mode 0777, non-root user","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (root,0644,default) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium default, volume mode 0644","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (root,0644,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium memory, volume mode 0644","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (root,0666,default) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium default, volume mode 0666","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (root,0666,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium memory, volume mode 0666","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (root,0777,default) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium default, volume mode 0777","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes should support (root,0777,tmpfs) [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium memory, volume mode 0777","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes volume on default medium should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium default, volume mode default","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes volume on tmpfs should have the correct mode [LinuxOnly] [NodeConformance] [Conformance]","testname":"EmptyDir, medium memory, volume mode default","file":"test/e2e/common/empty_dir.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [LinuxOnly] [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] files with FSGroup ownership should support (root,0644,tmpfs)","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is non-root","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] new files should be created with FSGroup ownership when container is root","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] nonexistent volume subPath should have the correct mode and owner using FSGroup","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] volume on default medium should have the correct mode using FSGroup","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir volumes when FSGroup is specified [NodeFeature:FSGroup] volume on tmpfs should have the correct mode using FSGroup","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] EmptyDir wrapper volumes should not conflict [Conformance]","testname":"EmptyDir Wrapper Volume, Secret and ConfigMap volumes, no conflict","file":"test/e2e/storage/empty_dir_wrapper.go","release":"1.13.0","conformance_test":true},{"test":"[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : configmap","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : projected","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Ephemeralstorage When pod refers to non-existent ephemeral storage should allow deletion of pod with invalid volume : secret","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Flexvolumes should be mountable when attachable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Flexvolumes should be mountable when non-attachable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] GCP Volumes GlusterFS should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] GCP Volumes NFSv3 should be mountable for NFSv3","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] GCP Volumes NFSv4 should be mountable for NFSv4","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] HostPath should give a volume the correct mode [LinuxOnly] [NodeConformance] [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] HostPath should support r/w [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] HostPath should support subPath [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: emptydir] [Testpattern: Inline-volume (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)(allowExpansion)] volume-expand Verify if offline PVC expansion works","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with mount options","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] provisioning should provision storage with pvc data source","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand should resize volume when PVC is edited while pod is using it","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)(allowExpansion)] volume-expand Verify if offline PVC expansion works","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should access volume from different nodes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with defaults","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volume-expand should not allow expansion of pvcs without AllowVolumeExpansion property","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (delayed binding)] topology should provision a volume and schedule a pod with AllowedTopologies","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext3)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (ext4)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should fail to schedule a pod which has topologies that conflict with AllowedTopologies","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Dynamic PV (immediate binding)] topology should provision a volume and schedule a pod with AllowedTopologies","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext3)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Inline-volume (ext4)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gcepd] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Inline-volume (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: gluster] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPathSymlink] [Testpattern: Inline-volume (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: hostPath] [Testpattern: Inline-volume (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: blockfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext3)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (ext4)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: block] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link-bindmounted] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir-link] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: dir] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: local][LocalVolumeType: tmpfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumeMode should fail in binding dynamic provisioned PV to PVC","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should access volume from different nodes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with defaults","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with mount options","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] provisioning should provision storage with pvc data source","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Dynamic PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Inline-volume (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (block volmode)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should be able to unmount after the subpath directory is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directories when readOnly specified in the volumeSource","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing directory","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support existing single file [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support file as subpath [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support non-existent path","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly directory specified in the volumeMount","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] subPath should support readOnly file specified in the volumeMount [LinuxOnly]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should allow exec of files on the volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (default fs)] volumes should store data","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should create sc, pod, pv, and pvc, read/write to the pv, and delete all created resources","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] In-tree Volumes [Driver: nfs] [Testpattern: Pre-provisioned PV (filesystem volmode)] volumeMode should not mount / map unused volumes in a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Mounted volume expand Should verify mounted devices can be resized","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes GCEPD should test that deleting a PVC before the pod does not cause pod deletion to fail on PD detach","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes GCEPD should test that deleting the Namespace of a PVC and Pod causes the successful detach of Persistent Disk","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes GCEPD should test that deleting the PV before the pod does not cause pod deletion to fail on PD detach","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeAffinity","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  Pod with node different from PV's NodeAffinity should fail scheduling due to different NodeSelector","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and read from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] One pod requesting one prebound PVC should be able to mount volume and write from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: blockfswithoutformat] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and read from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: block] One pod requesting one prebound PVC should be able to mount volume and write from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: block] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: block] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and read from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] One pod requesting one prebound PVC should be able to mount volume and write from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link-bindmounted] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and read from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link] One pod requesting one prebound PVC should be able to mount volume and write from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir-link] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and read from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir] One pod requesting one prebound PVC should be able to mount volume and write from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: dir] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and read from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] One pod requesting one prebound PVC should be able to mount volume and write from pod1","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Set fsGroup for local volume should set different fsGroup for second pod if first pod is deleted","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume at the same time should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes-local  [Volume type: tmpfs] Two pods mounting a local volume one after the other should be able to write from pod1 and read from pod2","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes NFS when invoking the Recycle reclaim policy should test that a PV becomes Available and is clean after the PVC is deleted.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 2 PVs and 4 PVCs: test write access","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes NFS with multiple PVs and PVCs all in same ns should create 3 PVs and 3 PVCs: test write access","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PV and a pre-bound PVC: test write access","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and a pre-bound PV: test write access","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs create a PVC and non-pre-bound PV: test write access","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes NFS with Single PV - PVC pairs should create a non-pre-bound PV and PVC: test write access","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes:vsphere should test that deleting a PVC before the pod does not cause pod deletion to fail on vsphere volume detach","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes:vsphere should test that deleting the Namespace of a PVC and Pod causes the successful detach of vsphere volume","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PersistentVolumes:vsphere should test that deleting the PV before the pod does not cause pod deletion to fail on vspehre volume detach","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Pod Disks should be able to delete a non-existent PD without error","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected combined should project all components that make up the projection API [Projection][NodeConformance] [Conformance]","testname":"Projected Volume, multiple projections","file":"test/e2e/common/projected_combined.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected configMap optional updates should be reflected in volume [NodeConformance] [Conformance]","testname":"Projected Volume, ConfigMap, create, update and delete","file":"test/e2e/common/projected_configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume as non-root [LinuxOnly] [NodeConformance] [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume as non-root [NodeConformance] [Conformance]","testname":"Projected Volume, ConfigMap, non-root user","file":"test/e2e/common/projected_configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume as non-root with defaultMode and fsGroup set [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume as non-root with FSGroup [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume [NodeConformance] [Conformance]","testname":"Projected Volume, ConfigMap, volume mode default","file":"test/e2e/common/projected_configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","testname":"Projected Volume, ConfigMap, volume mode 0400","file":"test/e2e/common/projected_configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume with mappings and Item mode set [LinuxOnly] [NodeConformance] [Conformance]","testname":"Projected Volume, ConfigMap, mapped, volume mode 0400","file":"test/e2e/common/projected_configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [LinuxOnly] [NodeConformance] [Conformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root [NodeConformance] [Conformance]","testname":"Projected Volume, ConfigMap, mapped, non-root user","file":"test/e2e/common/projected_configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [LinuxOnly] [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume with mappings as non-root with FSGroup [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected configMap should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","testname":"Projected Volume, ConfigMap, mapped","file":"test/e2e/common/projected_configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected configMap should be consumable in multiple volumes in the same pod [NodeConformance] [Conformance]","testname":"Projected Volume, ConfigMap, multiple volume paths","file":"test/e2e/common/projected_configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected configMap updates should be reflected in volume [NodeConformance] [Conformance]","testname":"Projected Volume, ConfigMap, update","file":"test/e2e/common/projected_configmap.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should provide container's cpu limit [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, CPU limits","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should provide container's cpu request [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, CPU request","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should provide container's memory limit [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, memory limits","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should provide container's memory request [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, memory request","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should provide node allocatable (cpu) as default cpu limit if the limit is not set [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, CPU limit, node allocatable","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should provide node allocatable (memory) as default memory limit if the limit is not set [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, memory limit, node allocatable","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [LinuxOnly] [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup and defaultMode [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [LinuxOnly] [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected downwardAPI should provide podname as non-root with fsgroup [NodeFeature:FSGroup]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected downwardAPI should provide podname only [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, pod name","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should set DefaultMode on files [LinuxOnly] [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, volume mode 0400","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should set mode on item file [LinuxOnly] [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, volume mode 0400","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should update annotations on modification [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, update annotation","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected downwardAPI should update labels on modification [NodeConformance] [Conformance]","testname":"Projected Volume, DownwardAPI, update labels","file":"test/e2e/common/projected_downwardapi.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected secret optional updates should be reflected in volume [NodeConformance] [Conformance]","testname":"Projected Volume, Secrets, create, update delete","file":"test/e2e/common/projected_secret.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected secret should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance]","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Projected secret should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","testname":"Project Volume, Secrets, non-root, custom fsGroup","file":"test/e2e/common/projected_secret.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected secret should be consumable from pods in volume [NodeConformance] [Conformance]","testname":"Projected Volume, Secrets, volume mode default","file":"test/e2e/common/projected_secret.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected secret should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","testname":"Projected Volume, Secrets, volume mode 0400","file":"test/e2e/common/projected_secret.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected secret should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","testname":"Projected Volume, Secrets, mapped, volume mode 0400","file":"test/e2e/common/projected_secret.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected secret should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","testname":"Projected Volume, Secrets, mapped","file":"test/e2e/common/projected_secret.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Projected secret should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","testname":"Projected Volume, Secrets, mapped, multiple paths","file":"test/e2e/common/projected_secret.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] PVC Protection Verify \"immediate\" deletion of a PVC that is not in active use by a pod","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PVC Protection Verify that PVC in active use by a pod is not removed immediately","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PVC Protection Verify that scheduling of a pod that uses PVC that is being deleted fails and the pod becomes Unschedulable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PV Protection Verify \"immediate\" deletion of a PV that is not bound to a PVC","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] PV Protection Verify that PV bound to a PVC is not removed immediately","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Secrets optional updates should be reflected in volume [NodeConformance] [Conformance]","testname":"Secrets Volume, create, update and delete","file":"test/e2e/common/secrets_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Secrets should be able to mount in a volume regardless of a different secret existing with same name in different namespace [NodeConformance] [Conformance]","testname":"Secrets Volume, volume mode default, secret with same name in different namespace","file":"test/e2e/common/secrets_volume.go","release":"1.12.0","conformance_test":true},{"test":"[sig-storage] Secrets should be consumable from pods in volume as non-root with defaultMode and fsGroup set [LinuxOnly] [NodeConformance] [Conformance]","testname":"Secrets Volume, volume mode 0440, fsGroup 1001 and uid 1000","file":"test/e2e/common/secrets_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Secrets should be consumable from pods in volume [NodeConformance] [Conformance]","testname":"Secrets Volume, default","file":"test/e2e/common/secrets_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Secrets should be consumable from pods in volume with defaultMode set [LinuxOnly] [NodeConformance] [Conformance]","testname":"Secrets Volume, volume mode 0400","file":"test/e2e/common/secrets_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Secrets should be consumable from pods in volume with mappings and Item Mode set [LinuxOnly] [NodeConformance] [Conformance]","testname":"Secrets Volume, mapping, volume mode 0400","file":"test/e2e/common/secrets_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Secrets should be consumable from pods in volume with mappings [NodeConformance] [Conformance]","testname":"Secrets Volume, mapping","file":"test/e2e/common/secrets_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Secrets should be consumable in multiple volumes in a pod [NodeConformance] [Conformance]","testname":"Secrets Volume, mapping multiple volume paths","file":"test/e2e/common/secrets_volume.go","release":"1.9.0","conformance_test":true},{"test":"[sig-storage] Secrets should be immutable if `immutable` field is set","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod [LinuxOnly] [Conformance]","testname":"SubPath: Reading content from a configmap volume.","file":"test/e2e/storage/subpath.go","release":"1.12.0","conformance_test":true},{"test":"[sig-storage] Subpath Atomic writer volumes should support subpaths with configmap pod with mountPath of existing file [LinuxOnly] [Conformance]","testname":"SubPath: Reading content from a configmap volume.","file":"test/e2e/storage/subpath.go","release":"1.12.0","conformance_test":true},{"test":"[sig-storage] Subpath Atomic writer volumes should support subpaths with downward pod [LinuxOnly] [Conformance]","testname":"SubPath: Reading content from a downwardAPI volume.","file":"test/e2e/storage/subpath.go","release":"1.12.0","conformance_test":true},{"test":"[sig-storage] Subpath Atomic writer volumes should support subpaths with projected pod [LinuxOnly] [Conformance]","testname":"SubPath: Reading content from a projected volume.","file":"test/e2e/storage/subpath.go","release":"1.12.0","conformance_test":true},{"test":"[sig-storage] Subpath Atomic writer volumes should support subpaths with secret pod [LinuxOnly] [Conformance]","testname":"SubPath: Reading content from a secret volume.","file":"test/e2e/storage/subpath.go","release":"1.12.0","conformance_test":true},{"test":"[sig-storage] Volume expand should allow expansion of block volumes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Volume expand should not allow expansion of pvcs without AllowVolumeExpansion property","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Volume expand should resize volume when PVC is edited while pod is using it","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Volume expand Verify if offline PVC expansion works","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Volume limits should verify that all nodes have volume limits","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Volume Placement should create and delete pod with multiple volumes from different datastore","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Volume Placement should create and delete pod with multiple volumes from same datastore","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Volume Placement should create and delete pod with the same volume source attach/detach to different worker nodes","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Volume Placement should create and delete pod with the same volume source on the same worker node","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Volume Placement test back to back pod creation and deletion with different volume sources on the same worker node","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Volumes ConfigMap should be mountable","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] vsphere statefulset vsphere statefulset testing","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod fails to get scheduled when conflicting volume topology (allowedTopologies) and pod scheduling constraints(nodeSelector) are specified","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on allowed zones specified in storage class","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on a VSAN capability, datastore and compatible zone specified in storage class","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in storage class","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on multiple zones specified in the storage class. (No shared datastores exist among both zones)","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and datastore specified in storage class","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV, based on the allowed zones, datastore and storage policy specified in storage class","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with allowedTopologies","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created and attached to a dynamically created PV with storage policy specified in storage class in waitForFirstConsumer binding mode with multiple allowedTopologies","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a pod is created on a non-Workspace zone and attached to a dynamically created PV, based on the allowed zones and storage policy specified in storage class","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify a PVC creation fails when multiple zones are specified in the storage class without shared datastores among the zones in waitForFirstConsumer binding mode","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify dynamically created pv with allowed zones specified in storage class, shows the right zone information on its labels","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify dynamically created pv with multiple zones specified in the storage class, shows both the zones on its labels","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation fails if no zones are specified in the storage class (No shared datastores exist among all the nodes)","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation fails if only datastore is specified in the storage class (No shared datastores exist among all the nodes)","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation fails if only storage policy is specified in the storage class (No shared datastores exist among all the nodes)","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation fails if the availability zone specified in the storage class have no shared datastores under it.","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation with an invalid VSAN capability along with a compatible zone combination specified in storage class fails","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation with compatible policy and datastore without any zones specified in the storage class fails (No shared datastores exist among all the nodes)","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation with incompatible datastore and zone combination specified in storage class fails","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation with incompatible storage policy along with compatible zone and datastore combination specified in storage class fails","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation with incompatible storagePolicy and zone combination specified in storage class fails","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation with incompatible zone along with compatible storagePolicy and datastore combination specified in storage class fails","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-storage] Zone Support Verify PVC creation with invalid zone specified in storage class fails","testname":null,"file":null,"release":null,"conformance_test":false},{"test":"[sig-ui] Kubernetes Dashboard should check that the kubernetes-dashboard instance is alive","testname":null,"file":null,"release":null,"conformance_test":false}]}
